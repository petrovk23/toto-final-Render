<current_code>

Procfile
web: gunicorn app:app

static/css/custom.css
/* static/css/custom.css */
table#combos-table tr.selected {
    background-color: #ffb347 !important;
    color: #000 !important;
    font-weight: bold;
}

static/js/main.js
// static/js/main.js
// This file can remain empty now since all Handsontable logic moved into combos.html

templates/game_options.html
{% extends "layout_no_sidebar.html" %}

{% block content %}
<div class="text-center">
    <h2>{{ game_config.name }} Options</h2>
    <div class="row mt-4 justify-content-center">
        <div class="col-md-5">
            <div class="card mb-4">
                <div class="card-header">
                    <h5>View/Edit Combinations</h5>
                </div>
                <div class="card-body">
                    <p>Browse, edit, and manage existing combinations for {{ game_config.name }}.</p>
                    <a href="{{ url_for('combos') }}" class="btn btn-primary">View Combos</a>
                </div>
            </div>
        </div>
        <div class="col-md-5">
            <div class="card mb-4">
                <div class="card-header">
                    <h5>Run Analysis</h5>
                </div>
                <div class="card-body">
                    <p>Perform advanced analysis on combinations for {{ game_config.name }}.</p>
                    <a href="{{ url_for('analysis_start') }}" class="btn btn-success">Start Analysis</a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

templates/combos.html
{% extends "layout.html" %}

{% block sidebar %}
<h5 class="mt-3">Combos Navigation</h5>
<div class="mb-2 d-flex justify-content-between">
    <button onclick="goTop()" class="btn btn-secondary">Top</button>
    <button class="btn btn-secondary" onclick="pageUp()">Page Up</button>
</div>
<div class="mb-2 d-flex justify-content-between">
    <button class="btn btn-secondary" onclick="bottom()">Bottom</button>
    <button class="btn btn-secondary" onclick="pageDown()">Page Down</button>
</div>

<form method="get" action="{{ url_for('combos') }}" class="mb-2">
    <div class="mb-2">
        <label>Page Size:</label>
        <input type="number" name="limit" value="{{ limit|default(20) }}" class="form-control">
    </div>
    <div class="mb-2">
        <label>Current Offset:</label>
        <input type="number" name="offset" value="{{ offset }}" class="form-control">
    </div>
    <button type="submit" class="btn btn-primary">Go</button>
</form>

<hr>

<a href="{{ url_for('download_all_combos') }}" class="btn btn-info mb-2">Download All as CSV</a>
{% endblock sidebar %}

{% block content %}
<h2>Existing Combos</h2>
<p>Total Count: <span id="total-count">{{ total_count }}</span></p>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@11.1.0/dist/handsontable.full.min.css">
<script src="https://cdn.jsdelivr.net/npm/handsontable@11.1.0/dist/handsontable.full.min.js"></script>

<div id="hot" style="width:100%; height:600px; overflow:auto;"></div>

<script>
let total_count = {{ total_count }};
let limit = parseInt('{{ limit|default(20) }}', 10);
let offset = parseInt('{{ offset }}', 10);

function updateTotalCount(delta) {
    total_count += delta;
    document.getElementById('total-count').textContent = total_count;
}

function navigate(o) {
    window.location.href = '{{ url_for("combos") }}?limit=' + limit + '&offset=' + o;
}
function goTop(){
    navigate(0);
}
function pageUp() {
    let newOffset = offset - limit;
    if (newOffset < 0) newOffset = 0;
    navigate(newOffset);
}
function bottom() {
    let newOffset = total_count - limit;
    if (newOffset < 0) newOffset = 0;
    navigate(newOffset);
}
function pageDown() {
    let newOffset = offset + limit;
    navigate(newOffset);
}

const container = document.getElementById('hot');
let hot;
let loading = false;

function loadData() {
  loading = true;
  fetch('/combos_data?limit=' + limit + '&offset=' + offset)
    .then(response => response.json())
    .then(data => {
      hot.loadData(data);
      loading = false;
    });
}

hot = new Handsontable(container, {
  data: [],
  colHeaders: ["Draw", "#1", "#2", "#3", "#4", "#5", "#6", "ID"],
  columns: [
    { data: 0, readOnly: true },
    { data: 1, type: 'numeric' },
    { data: 2, type: 'numeric' },
    { data: 3, type: 'numeric' },
    { data: 4, type: 'numeric' },
    { data: 5, type: 'numeric' },
    { data: 6, type: 'numeric' },
    { data: 7, readOnly: true }  // hidden ID
  ],
  hiddenColumns: {
    columns: [7],
    indicators: false
  },
  rowHeaders: true,
  manualRowMove: true,
  copyPaste: true,
  contextMenu: {
    items: {
      "row_above": { name: "Insert row above" },
      "row_below": { name: "Insert row below" },
      "remove_row": { name: "Remove row" },
      "copy": { name: "Copy" },
      "paste": {
        name: "Paste",
        callback: async function() {
          try {
            const text = await navigator.clipboard.readText();
            if (!text) return;
            const cpPlugin = this.getPlugin('CopyPaste');
            cpPlugin.paste(text);
          } catch (err) {
            console.error("Error reading clipboard:", err);
            alert("Unable to paste. Your browser may require HTTPS or permission for clipboard access.");
          }
        }
      }
    }
  },
  licenseKey: 'non-commercial-and-evaluation'
});

let rowsToRemoveIDs = [];

// Hook to track which rows are removed
hot.addHook('beforeRemoveRow', (index, amount) => {
  rowsToRemoveIDs = [];
  for (let i = 0; i < amount; i++) {
    const rowData = hot.getDataAtRow(index + i);
    if (rowData && rowData[7] != null) {
      rowsToRemoveIDs.push(rowData[7]);
    }
  }
});

// After row removal, call the server to actually delete
hot.addHook('afterRemoveRow', (index, amount, source) => {
  if (rowsToRemoveIDs.length > 0) {
    const formData = new URLSearchParams();
    rowsToRemoveIDs.forEach(id => formData.append('ids[]', id));

    fetch('/delete_combos_hot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: formData
    })
    .then(r => {
      if (!r.ok) {
        alert("Error deleting combos");
      } else {
        updateTotalCount(-amount);
        loadData();
      }
    });
  } else {
    loadData();
  }
});

// After row creation, call the server to insert
hot.addHook('afterCreateRow', (index, amount, source) => {
  let after_id = null;
  if (index > 0) {
    const prevRow = hot.getDataAtRow(index - 1);
    if (prevRow && prevRow[7] != null) {
      after_id = prevRow[7];
    }
  }
  fetch('/add_combo_hot', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ after_id: after_id || '' })
  }).then(r => {
    if (!r.ok) {
      alert("Invalid combo insert");
    } else {
      updateTotalCount(1);

      // IMPORTANT: we replicate the original logic so that after adding a row,
      // we jump to the new bottom page so the user sees it:
      offset = total_count - limit;
      if (offset < 0) offset = 0;
      loadData();
    }
  });
});

// After row move, reorder
hot.addHook('afterRowMove', (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {
  if (!orderChanged) return;
  const allData = hot.getData();
  const idsOrder = allData.map(r => r[7]).filter(x => x != null);
  const formData = new URLSearchParams();
  idsOrder.forEach(id => formData.append('new_order[]', id));

  fetch('/move_row_hot', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: formData
  }).then(r => {
    if (!r.ok) {
      alert("Error moving row");
    } else {
      loadData();
    }
  });
});

// After a cell changes, update on server
hot.addHook('afterChange', (changes, source) => {
  if (!changes || loading) return;
  if (source === 'loadData') return;

  const changedRows = new Set();
  changes.forEach(([row, prop, oldVal, newVal]) => {
    if (oldVal !== newVal) {
      changedRows.add(row);
    }
  });
  if (changedRows.size === 0) return;

  let promises = [];
  changedRows.forEach(rowIndex => {
    const rowData = hot.getDataAtRow(rowIndex);
    const draw_id = rowData[7];
    if (draw_id != null) {
      const nums = {
        id: draw_id,
        num1: rowData[1],
        num2: rowData[2],
        num3: rowData[3],
        num4: rowData[4],
        num5: rowData[5],
        num6: rowData[6]
      };
      promises.push(
        fetch('/update_combo_hot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams(nums)
        })
        .then(resp => {
          if (!resp.ok) alert("Invalid combo update");
        })
      );
    }
  });

  Promise.all(promises).then(() => loadData());
});

loadData();
</script>
{% endblock content %}

templates/index.html
{% extends "layout_no_sidebar.html" %}

{% block content %}
<div class="text-center">
    <h2>Toto Combinations Analyzer</h2>
    <div class="row mt-4">
        <div class="col-md-6 offset-md-3">
            <div class="card">
                <div class="card-header">
                    <h5>Select Game</h5>
                </div>
                <div class="card-body">
                    <div class="list-group">
                        {% for game_type, config in games.items() %}
                        <a href="{{ url_for('select_game', game_type=game_type) }}" class="list-group-item list-group-item-action">
                            {{ config.name }}
                        </a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

templates/layout.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Toto Combinations Analyzer</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/custom.css') }}">

    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <style>
        .sidebar {
            position: sticky;
            top: 0;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            padding: 1rem;
        }
        #combos-table thead th {
            position: sticky;
            top: 0;
            background: #ffffff;
            z-index: 10;
        }
        @media (min-width: 768px) {
            .sidebar {
                width: 250px;
            }
        }
        .main-content {
            flex-grow: 1;
        }
    </style>
</head>
<body class="bg-light">
    <!-- Navbar with brand (left), game label (center), back link (right) -->
    <nav class="navbar navbar-dark bg-dark mb-3">
        <div class="container-fluid d-flex justify-content-between align-items-center">

            <!-- Left: brand -->
            <a class="navbar-brand" href="{{ url_for('index') }}">
                Toto Combinations Analyzer
            </a>

            <!-- Center: game label (if any) -->
            <div class="text-light text-center flex-fill">
                {% if session.get('game_type') %}
                    <span style="font-weight: 500;">
                        {{ config.GAMES[session.get('game_type')]['name'] }}
                    </span>
                {% endif %}
            </div>

            <!-- Right: back link logic -->
            <div class="d-flex align-items-center">
                {% if request.endpoint == 'index' %}
                    <!-- On the index page, no back link -->

                {% elif request.endpoint == 'select_game' %}
                    <!-- On the select_game page, link back to index -->
                    <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                        Back to Game Selection
                    </a>

                {% else %}
                    {% if session.get('game_type') %}
                        <a href="{{ url_for('select_game', game_type=session['game_type']) }}"
                           class="btn btn-outline-light">
                            Back to Options
                        </a>
                    {% else %}
                        <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                            Back to Game Selection
                        </a>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Left Pane (sidebar) -->
            <div class="col-12 col-md-3 col-lg-2 sidebar">
                {% block sidebar %}{% endblock sidebar %}
            </div>

            <!-- Main Content -->
            <div class="col-12 col-md-9 col-lg-10 p-4 main-content">
                {% block content %}{% endblock content %}
            </div>
        </div>
    </div>
</body>
</html>

templates/layout_no_sidebar.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Toto Combinations Analyzer</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/custom.css') }}">

    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <style>
        /* We remove the sidebar entirely */
        .main-centered {
            display: flex;
            justify-content: center;
        }
        .content-wrapper {
            max-width: 900px; /* adjustable */
            width: 100%;
        }
    </style>
</head>
<body class="bg-light">
    <!-- Navbar with brand (left), game label (center), back link (right) -->
    <nav class="navbar navbar-dark bg-dark mb-3">
        <div class="container-fluid d-flex justify-content-between align-items-center">

            <!-- Left: brand -->
            <a class="navbar-brand" href="{{ url_for('index') }}">
                Toto Combinations Analyzer
            </a>

            <!-- Right: back link logic -->
            <div class="d-flex align-items-center">
                {% if request.endpoint == 'index' %}
                    <!-- On the index page, no back link -->

                {% elif request.endpoint == 'select_game' %}
                    <!-- On the select_game page, link back to index -->
                    <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                        Back to Game Selection
                    </a>

                {% else %}
                    {% if session.get('game_type') %}
                        <a href="{{ url_for('select_game', game_type=session['game_type']) }}"
                           class="btn btn-outline-light">
                            Back to Options
                        </a>
                    {% else %}
                        <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                            Back to Game Selection
                        </a>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </nav>

    <!-- Single-column, centered content -->
    <div class="container main-centered">
        <div class="content-wrapper">
            {% block content %}{% endblock content %}
        </div>
    </div>
</body>
</html>

templates/results.html
{% extends "layout.html" %}

{% block content %}
<h4>Toto Combinations Analyzer</h4>

{% if selected_df is none and top_df is none %}
<div class="alert alert-info">
    <p>Ready to run analysis. Adjust parameters and click "Run Analysis".</p>
</div>
{% endif %}

<!-- We replace the old progress bar with a simple "Processing..." spinner/message. -->
<div id="analysis-processing" style="display: none;" class="mt-2">
    <div class="d-flex align-items-center">
        <div class="spinner-border spinner-border-sm text-primary me-2" role="status"></div>
        <small>Processing...</small>
    </div>
</div>

<hr class="my-2">

<div id="results-container">
    {% if top_df is not none %}
    <small class="text-muted">Completed in {{ elapsed }} seconds.</small>

    <h6 class="mt-3 mb-2">{% if l == -1 %}Analysis Chain Results:{% else %}Top-ranked combinations:{% endif %}</h6>
    <table class="table table-sm table-striped table-hover">
        <thead>
            <tr>
                {% if l == -1 %}
                <th style="width: 100px;">Analysis #</th>
                <th style="width: 100px;">For Draw</th>
                {% endif %}
                <th style="width: 300px;">Combination</th>
                <th style="width: 100px;">Avg Rank</th>
                <th style="width: 100px;">Min Rank</th>
                {% if l == -1 %}
                <th style="width: 180px;">Top-Ranked Duration</th>
                {% endif %}
                <th>Subsets <small class="text-muted">(click to expand)</small></th>
            </tr>
        </thead>
        <tbody>
        {% for idx, row in top_df.iterrows() %}
            <tr>
                {% if l == -1 %}
                <td>{{ idx + 1 }}</td>
                <td>{{ row['Analysis Start Draw'] }}</td>
                {% endif %}
                <td>{{ row['Combination'] }}</td>
                <td>{{ "%.2f"|format(row['Average Rank']) }}</td>
                <td>{{ "%.0f"|format(row['MinValue']) }}</td>
                {% if l == -1 %}
                <td>{{ row['Draws Until Common Subset'] }}</td>
                {% endif %}
                <td class="subset-cell">
                    <span class="subset-preview">{{ row['Subsets'][:50] }}...</span>
                    <span class="subset-full" style="display: none;">{{ row['Subsets'] }}</span>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>

    <a href="{{ url_for('download_top_csv') }}" class="btn btn-info btn-sm">Download Top CSV</a>

    {% if selected_df is not none %}
    <h6 class="mt-4 mb-2">Top-ranked combinations w/o overlapping subsets:</h6>
    <table class="table table-sm table-striped table-hover">
        <thead>
            <tr>
                <th style="width: 300px;">Combination</th>
                <th style="width: 100px;">Avg Rank</th>
                <th style="width: 100px;">Min Rank</th>
                <th>Subsets <small class="text-muted">(click to expand)</small></th>
            </tr>
        </thead>
        <tbody>
        {% for idx, row in selected_df.iterrows() %}
            <tr>
                <td>{{ row['Combination'] }}</td>
                <td>{{ "%.2f"|format(row['Average Rank']) }}</td>
                <td>{{ "%.0f"|format(row['MinValue']) }}</td>
                <td class="subset-cell">
                    <span class="subset-preview">{{ row['Subsets'][:50] }}...</span>
                    <span class="subset-full" style="display: none;">{{ row['Subsets'] }}</span>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
    <a href="{{ url_for('download_selected_csv') }}" class="btn btn-info btn-sm">Download Selected CSV</a>
    {% endif %}
    {% endif %}
</div>

<style>
.table { margin-bottom: 0.5rem; }
.table td, .table th { padding: 0.25rem 0.5rem; }
.subset-cell {
    cursor: pointer;
    font-size: 12px;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.subset-cell:hover {
    background-color: #f8f9fa;
}
.subset-cell.expanded {
    max-width: none;
    white-space: normal;
    word-break: break-all;
}
.subset-preview, .subset-full {
    font-family: monospace;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const runBtn = document.getElementById('run-analysis-btn');
    const processingContainer = document.getElementById('analysis-processing');
    const resultsContainer = document.getElementById('results-container');

    let pollInterval = null;

    function createParams() {
        const params = new URLSearchParams();
        const offsetEl = document.getElementById('param-offset-last');
        let offsetVal = offsetEl ? offsetEl.value : "0";

        params.append('offset_last', offsetVal);
        params.append('j', document.getElementById('param-j').value);
        params.append('k', document.getElementById('param-k').value);
        params.append('m', document.getElementById('param-m').value);
        params.append('l', document.getElementById('param-l').value);
        params.append('n', document.getElementById('param-n').value);
        return params;
    }

    function startAnalysis() {
        resultsContainer.style.display = 'none';
        processingContainer.style.display = 'block';

        fetch('/analysis_run', {
            method: 'POST',
            body: createParams(),
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        })
        .then(resp => {
            if (pollInterval) clearInterval(pollInterval);
            pollInterval = setInterval(checkDone, 1000);
        });
    }

    function checkDone() {
        fetch('/analysis_progress')
        .then(resp => {
            if (!resp.ok) throw new Error('Error fetching progress');
            return resp.json();
        })
        .then(data => {
            if (!data.in_progress && data.done) {
                clearInterval(pollInterval);
                pollInterval = null;
                const url = new URL('/analysis', window.location.href);
                const params = createParams();
                params.forEach((value, key) => url.searchParams.set(key, value));
                window.location.href = url.toString();
            }
        })
        .catch(err => {
            console.error("Check-done error:", err);
            clearInterval(pollInterval);
        });
    }

    document.querySelectorAll('.subset-cell').forEach(cell => {
        cell.addEventListener('click', function() {
            const preview = this.querySelector('.subset-preview');
            const full = this.querySelector('.subset-full');
            const isExpanded = this.classList.contains('expanded');

            if (isExpanded) {
                preview.style.display = '';
                full.style.display = 'none';
                this.classList.remove('expanded');
            } else {
                preview.style.display = 'none';
                full.style.display = '';
                this.classList.add('expanded');
            }
        });
    });

    if (runBtn) {
        runBtn.addEventListener('click', startAnalysis);
    }
});
</script>
{% endblock content %}

{% block sidebar %}
<h5 class="mt-3">Parameters</h5>

<div class="mb-2">
    <label>Offset from last draw:</label>
    <input id="param-offset-last" type="number" class="form-control form-control-sm"
           value="{{ offset_last|default(0) }}">
</div>

<div class="mb-2">
    <label>n-number subsets of {{ game_config.max_number }}:</label>
    <input id="param-j" type="number" class="form-control form-control-sm" value="{{ j }}">
</div>

<div class="mb-2">
    <label>k-number subsets of n:</label>
    <input id="param-k" type="number" class="form-control form-control-sm" value="{{ k }}">
</div>

<div class="mb-2">
    <label>Sorting option:</label>
    <select id="param-m" class="form-select form-select-sm">
        <option value="avg" {% if m=='avg' %}selected{% endif %}>avg</option>
        <option value="min" {% if m=='min' or not m %}selected{% endif %}>min</option>
    </select>
</div>

<div class="mb-2">
    <label>Number of top-ranked combinations:</label>
    <input id="param-l" type="number" class="form-control form-control-sm" value="{{ l|default(1) }}">
</div>

<div class="mb-2">
    <label>Number of top-ranked combinations w/o overlapping subsets:</label>
    <input id="param-n" type="number" class="form-control form-control-sm" value="{{ n|default(0) }}">
</div>

<button id="run-analysis-btn" class="btn btn-danger btn-sm">Run Analysis</button>
{% endblock sidebar %}

analysis.py
# analysis.py
"""
analysis.py
-----------
This module orchestrates the analysis by calling a compiled C library (the "C_engine"),
thereby performing the same logic that existed in the Python-only approach but far more
quickly in C. The C library is loaded via ctypes.

Major points about this file:
1) We load the C library (libanalysis_engine.so on Linux) from the 'C_engine/src' folder.
2) We define a ctypes.Structure (AnalysisResultItem) mirroring the C struct that holds
   the analysis results.
3) We declare function signatures for run_analysis_c(...) and free_analysis_results(...)
   so that Python knows how to call into the C code.
4) In run_analysis(...), we read the draws from the database, prepare them in the format
   the C code expects, then invoke run_analysis_c(...).
5) We parse the returned pointers into Python objects and free the allocated results
   by calling free_analysis_results(...).
6) This approach preserves the original logic for "chain analysis" (l == -1) and "normal"
   top-l analysis (l >= 1), so that the final outcome matches your original Python results.
7) The only difference from the Python-only version is performance: this C-based code runs
   orders of magnitude faster, especially on larger sets of combos.

Important considerations:
- We do no partial progress reporting from the C code (the callback is effectively ignored).
- For chain analysis (l == -1), we return (selected_df=None, top_df=chain_results, elapsed).
- For normal analysis (l >= 1), we return (selected_df, top_df, elapsed).
- The "selected_df" portion is the "non-overlapping subsets" portion in the Python code;
  the C code lumps them into the second portion of the returned array, but we split them
  accordingly.
"""

import ctypes
import os
import time
import sqlite3
from database import get_db_connection
from config import Config

# ------------------------------------------------------------------------------
# 1) Load the compiled C library.
#    We assume the library is named 'libanalysis_engine.so' and is placed
#    in a subfolder "C_engine/src" next to this 'analysis.py'.
# ------------------------------------------------------------------------------
LIB_PATH = os.path.join(
    os.path.dirname(__file__),
    "C_engine", "src", "libanalysis_engine.so"
)
analysis_lib = ctypes.CDLL(LIB_PATH)

# ------------------------------------------------------------------------------
# 2) Define the AnalysisResultItem structure in Python
#    This must match the fields in analysis_engine.h
# ------------------------------------------------------------------------------
class AnalysisResultItem(ctypes.Structure):
    _fields_ = [
        ("combination", ctypes.c_char * 256),
        ("avg_rank", ctypes.c_double),
        ("min_value", ctypes.c_double),
        ("subsets", ctypes.c_char * 65536),
        ("draw_offset", ctypes.c_int),
        ("draws_until_common", ctypes.c_int),
        ("analysis_start_draw", ctypes.c_int),
        ("is_chain_result", ctypes.c_int),
    ]

# ------------------------------------------------------------------------------
# 3) Tell ctypes about the run_analysis_c(...) function signature
# ------------------------------------------------------------------------------
analysis_lib.run_analysis_c.argtypes = [
    ctypes.c_char_p,                               # const char* game_type
    ctypes.POINTER(ctypes.POINTER(ctypes.c_int)),  # int** draws
    ctypes.c_int,                                  # draws_count
    ctypes.c_int,                                  # j
    ctypes.c_int,                                  # k
    ctypes.c_char_p,                               # m
    ctypes.c_int,                                  # l
    ctypes.c_int,                                  # n
    ctypes.c_int,                                  # last_offset
    ctypes.POINTER(ctypes.c_int)                   # out_len (pointer)
]
analysis_lib.run_analysis_c.restype = ctypes.POINTER(AnalysisResultItem)

# ------------------------------------------------------------------------------
# 4) Tell ctypes about the free_analysis_results(...) function signature
# ------------------------------------------------------------------------------
analysis_lib.free_analysis_results.argtypes = [ctypes.POINTER(AnalysisResultItem)]
analysis_lib.free_analysis_results.restype = None


# ------------------------------------------------------------------------------
# 5) The main function called by app.py to run the analysis
# ------------------------------------------------------------------------------
def run_analysis(game_type='6_42', j=6, k=3, m='min', l=1, n=0,
                 last_offset=0):
    """
    This function replicates your Python "analysis" logic but uses the C engine
    for all heavy computations.

    Parameters:
    -----------
    game_type : str  (e.g. '6_42')
    j         : int  (the 'n-number subsets' or 'j' in the original code)
    k         : int  (the 'k-number subsets of n')
    m         : str  (sorting option, 'avg' or 'min')
    l         : int  (number of top-ranked combos, or -1 for chain analysis)
    n         : int  (number of top-ranked combos w/o overlapping subsets)
    last_offset : int (offset from the last draw, used in both chain & normal)
    progress_callback : function (ignored here, we do not do partial updates in C)
    should_stop : function (ignored as well for simplicity in C)

    Returns:
    --------
    (selected_df, top_df, elapsed_seconds)

    Where:
      - For chain analysis (l == -1), top_df is actually the chain results,
        selected_df is None.
      - For normal analysis (l >= 1), top_df is the top-l combos, selected_df
        is the additional "non-overlapping" portion (up to n combos).
      - elapsed_seconds is an int giving total time spent.

    Raises:
    -------
    OSError if the .so library isn't found or can't be loaded.
    """
    start_time = time.time()

    # 1) Load draws from the DB
    conn = get_db_connection(game_type)
    c = conn.cursor()
    row_count = c.execute("SELECT COUNT(*) as cnt FROM draws").fetchone()["cnt"]

    # Constrain last_offset to [0, row_count]
    if last_offset < 0:
        last_offset = 0
    if last_offset > row_count:
        last_offset = row_count

    # Actually fetch the draws
    draws = c.execute(
        "SELECT number1, number2, number3, number4, number5, number6 FROM draws ORDER BY sort_order"
    ).fetchall()
    conn.close()

    draws_count = len(draws)

    # 2) Convert these draws into an array-of-pointers for the C library
    draws_c = (ctypes.POINTER(ctypes.c_int) * draws_count)()
    for i, row in enumerate(draws):
        row_arr = (ctypes.c_int * 6)()
        # If any row element is None, we clamp it to 1 or some fallback
        for jx in range(6):
            row_arr[jx] = row[jx] if row[jx] is not None else 1
        draws_c[i] = row_arr

    # 3) Prepare out_len
    out_len = ctypes.c_int(0)

    # 4) Call the C function
    results_ptr = analysis_lib.run_analysis_c(
        game_type.encode('utf-8'),  # const char*
        draws_c,                    # int** draws
        draws_count,                # draws_count
        j,                          # j
        k,                          # k
        m.encode('utf-8'),         # m
        l,                          # l
        n,                          # n
        last_offset,                # last_offset
        ctypes.byref(out_len)       # out_len
    )

    res_count = out_len.value

    # 5) Convert the returned results into Python objects
    if not results_ptr or res_count <= 0:
        # No results or error
        elapsed = round(time.time() - start_time)
        return None, None, elapsed

    python_results = []
    for i in range(res_count):
        item = results_ptr[i]
        python_results.append({
            "combination": item.combination.decode('utf-8'),
            "avg_rank": item.avg_rank,
            "min_value": item.min_value,
            "subsets": item.subsets.decode('utf-8'),
            "draw_offset": item.draw_offset,
            "draws_until_common": item.draws_until_common,
            "analysis_start_draw": item.analysis_start_draw,
            "is_chain_result": item.is_chain_result
        })

    # 6) Free the results in C
    analysis_lib.free_analysis_results(results_ptr)

    # 7) Build Pandas DataFrames in the same shape as the original code expects
    import pandas as pd
    elapsed = round(time.time() - start_time)

    # Chain analysis
    if l == -1:
        # If chain analysis, just return them all in top_df
        chain_data = []
        for row in python_results:
            chain_data.append({
                'Offset': row['draw_offset'],
                'Combination': row['combination'],
                'Average Rank': row['avg_rank'],
                'MinValue': row['min_value'],
                'Subsets': row['subsets'],
                'Draws Until Common Subset': row['draws_until_common'],
                'Analysis Start Draw': row['analysis_start_draw'],
                'Draw Count': row['draw_offset']
            })
        if len(chain_data) == 0:
            return None, None, elapsed
        top_df = pd.DataFrame(chain_data)
        selected_df = None
        return selected_df, top_df, elapsed

    # Normal analysis
    else:
        # The C code arranges the top-l combos first, then up to n "selected" combos next
        top_data = []
        selected_data = []
        # figure out the boundary
        # If we had "filled" combos for top-l in C, that count is min(l, actual).
        # Then "n" combos follow for the "selected" portion, if any.
        # So we do the same split here:
        top_count = min(l, res_count)
        for i in range(top_count):
            r = python_results[i]
            top_data.append({
                'Combination': r['combination'],
                'Average Rank': r['avg_rank'],
                'MinValue': r['min_value'],
                'Subsets': r['subsets']
            })
        if n > 0 and res_count > top_count:
            selected_count = min(n, res_count - top_count)
            for i in range(top_count, top_count + selected_count):
                r = python_results[i]
                selected_data.append({
                    'Combination': r['combination'],
                    'Average Rank': r['avg_rank'],
                    'MinValue': r['min_value'],
                    'Subsets': r['subsets']
                })

        top_df = pd.DataFrame(top_data) if top_data else None
        selected_df = pd.DataFrame(selected_data) if selected_data else None
        return selected_df, top_df, elapsed

app.py
# app.py
"""
app.py
------
This is the Flask application entry point. It handles:
- Session setup
- Routing for pages (index, select_game, combos, analysis, etc.)
- Database I/O for combos
- The analysis run invocation
- A simple "processing" status while analysis runs (replacing the previous progress bar)
- The ability to cancel any ongoing analysis if a new one starts.

Key changes to support the new functionality:
- In /analysis_run, if an analysis is already in progress, we cancel (join) the existing
  thread before starting a new one. This way, the user doesn't need to wait for the
  previous one to finish if they made a mistake and want to run again.
- The progress bar has been replaced with a simple "Processing..." spinner/message in
  templates/results.html, and we do not display partial progress.
"""

import os
import io
import pandas as pd
import threading
import time

from flask import Flask, render_template, request, make_response, jsonify, redirect, url_for, session
from flask_session import Session

from database import *
from analysis import run_analysis
from config import Config

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-here'
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = False
Session(app)

analysis_in_progress = False
analysis_selected_df = None
analysis_top_df = None
analysis_elapsed = None
analysis_thread = None
analysis_cancel_requested = False

@app.context_processor
def utility_processor():
    return dict(config=Config)

@app.route('/')
def index():
    """
    The home page: lists all available games, e.g. 6/42, 6/49, etc.
    """
    return render_template('index.html', games=Config.GAMES)

@app.route('/select_game/<game_type>')
def select_game(game_type):
    """
    Store the selected game in the session, then show the game options:
    'View/Edit Combinations' and 'Run Analysis'.
    """
    if game_type not in Config.GAMES:
        return redirect(url_for('index'))
    session['game_type'] = game_type
    game_config = Config.GAMES[game_type]
    return render_template('game_options.html', game_type=game_type, game_config=game_config)

@app.route('/combos', methods=['GET'])
def combos():
    """
    Shows the combos page with Handsontable.
    We preserve the original logic:
      - If no 'offset' is provided, jump to the bottom (last page).
      - If 'offset' is explicitly set, we use that.
    """
    game_type = session.get('game_type', '6_42')
    if not game_type:
        return redirect(url_for('index'))

    limit = request.args.get('limit', 20, type=int)
    offset_param = request.args.get('offset', None)
    total_count = count_draws(game_type)

    if offset_param is None:
        # Jump to last page
        offset = max(total_count - limit, 0)
    else:
        offset = int(offset_param)

    return render_template(
        'combos.html',
        limit=limit,
        offset=offset,
        total_count=total_count,
        game_config=Config.GAMES[game_type]
    )

@app.route('/combos_data', methods=['GET'])
def combos_data():
    """
    Endpoint that returns JSON data for the combos in the specified limit/offset.
    The JavaScript in combos.html loads this data into Handsontable.
    """
    game_type = session.get('game_type', '6_42')
    limit = request.args.get('limit', 20, type=int)
    offset = request.args.get('offset', 0, type=int)
    draws = get_draws(game_type, limit=limit, offset=offset)
    data = []
    for d in draws:
        data.append([
            d['draw_number'],
            d['number1'],
            d['number2'],
            d['number3'],
            d['number4'],
            d['number5'],
            d['number6'],
            d['id']
        ])
    return jsonify(data)

@app.route('/update_combo_hot', methods=['POST'])
def update_combo_hot():
    """
    Called by the Handsontable afterChange hook to update a row.
    """
    game_type = session.get('game_type', '6_42')
    draw_id = request.form.get('id', type=int)
    nums = [
        request.form.get('num1', type=int),
        request.form.get('num2', type=int),
        request.form.get('num3', type=int),
        request.form.get('num4', type=int),
        request.form.get('num5', type=int),
        request.form.get('num6', type=int),
    ]
    update_draw(draw_id, nums, game_type)
    return "OK"

@app.route('/add_combo_hot', methods=['POST'])
def add_combo_hot():
    """
    Called by the Handsontable 'afterCreateRow' hook to insert a new row.
    We place it after a given ID if provided, then re-run renumbering.
    """
    game_type = session.get('game_type', '6_42')
    after_id = request.form.get('after_id', type=int)
    insert_draw([None, None, None, None, None, None], game_type, after_id=after_id)
    return "OK"

@app.route('/delete_combos_hot', methods=['POST'])
def delete_combos_hot():
    """
    Called when the user removes rows in Handsontable.
    We delete each ID from the DB, then renumber.
    """
    game_type = session.get('game_type', '6_42')
    ids = request.form.getlist('ids[]', type=int)
    if not ids:
        return "No IDs", 400
    delete_draws(ids, game_type)
    return "OK"

@app.route('/move_row_hot', methods=['POST'])
def move_row_hot():
    """
    Called after a user manually reorders rows in Handsontable.
    We reorder 'sort_order' accordingly, then renumber them so that
    draw_number fields remain consistent.
    """
    game_type = session.get('game_type', '6_42')
    new_order = request.form.getlist('new_order[]', type=int)
    conn = get_db_connection(game_type)
    c = conn.cursor()
    for i, id_val in enumerate(new_order, start=1):
        c.execute("UPDATE draws SET sort_order=? WHERE id=?", (i, id_val))
    conn.commit()
    conn.close()
    renumber_all(game_type)
    return "OK"

@app.route('/download_all_combos', methods=['GET'])
def download_all_combos():
    """
    Let users download all combos as CSV.
    """
    game_type = session.get('game_type', '6_42')
    rows = get_all_draws(game_type)
    df = pd.DataFrame([
        [
            row['draw_number'],
            row['number1'],
            row['number2'],
            row['number3'],
            row['number4'],
            row['number5'],
            row['number6']
        ]
        for row in rows
    ], columns=['Draw', '#1', '#2', '#3', '#4', '#5', '#6'])
    output = io.StringIO()
    df.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=all_combos.csv"
    response.headers["Content-type"] = "text/csv"
    return response

@app.route('/analysis_start', methods=['GET'])
def analysis_start():
    """
    Renders the analysis page (results.html) with empty results, ready for user parameters.
    """
    game_type = session.get('game_type', '6_42')
    if not game_type:
        return redirect(url_for('index'))
    game_config = Config.GAMES[game_type]
    j_default = 6
    return render_template(
        'results.html',
        game_config=game_config,
        selected_df=None,
        top_df=None,
        elapsed=None,
        j=j_default,
        k=3,
        m='min',
        l=1,
        n=0,
        offset_last=0
    )

@app.route('/analysis')
def analysis_route():
    """
    Once the analysis thread finishes, it stores the results in analysis_selected_df
    and analysis_top_df, plus analysis_elapsed. We display them here.
    """
    game_type = session.get('game_type', '6_42')
    j = request.args.get('j', 6, type=int)
    k = request.args.get('k', 3, type=int)
    m = request.args.get('m', 'min')
    l = request.args.get('l', 1, type=int)
    n_val = request.args.get('n', 0, type=int)
    offset_last = request.args.get('offset_last', 0, type=int)

    global analysis_selected_df, analysis_top_df, analysis_elapsed
    return render_template(
        'results.html',
        j=j, k=k, m=m, l=l, n=n_val,
        offset_last=offset_last,
        selected_df=analysis_selected_df,
        top_df=analysis_top_df,
        elapsed=analysis_elapsed,
        game_config=Config.GAMES[game_type]
    )

@app.route('/analysis_run', methods=['POST'])
def analysis_run():
    """
    Starts the analysis in a separate thread. If an existing analysis is in progress,
    we cancel (join) it first, so the user doesn't have to wait for a mistake run to finish.
    """
    global analysis_in_progress, analysis_processed, analysis_total
    global analysis_selected_df, analysis_top_df, analysis_elapsed
    global analysis_thread, analysis_cancel_requested

    game_type = session.get('game_type', '6_42')
    j = request.form.get('j', type=int, default=6)
    k = request.form.get('k', type=int, default=3)
    m = request.form.get('m', type=str, default='min')
    l = request.form.get('l', type=int, default=1)
    n_val = request.form.get('n', type=int, default=0)
    offset_val = request.form.get('offset_last', type=int, default=0)

    # Reset all analysis state
    analysis_cancel_requested = True
    analysis_in_progress = False
    analysis_thread = None
    analysis_selected_df = None
    analysis_top_df = None
    analysis_elapsed = None

    # Wait a moment to ensure old state is cleared
    time.sleep(0.1)

    # Reset cancel flag before starting new analysis
    analysis_cancel_requested = False

    analysis_in_progress = True
    analysis_selected_df = None
    analysis_top_df = None
    analysis_elapsed = None

    def worker():
        global analysis_in_progress, analysis_selected_df, analysis_top_df, analysis_elapsed
        global analysis_cancel_requested
        print("Analysis starting...")
        try:
            if analysis_cancel_requested:
                analysis_in_progress = False
                return

            sel_df, top_df, elapsed = run_analysis(
                game_type=game_type,
                j=j, k=k, m=m, l=l, n=n_val,
                last_offset=offset_val
            )

            # For both regular and chain analysis, check cancellation after completion
            if analysis_cancel_requested:
                analysis_in_progress = False
                return

            print(f"Analysis completed in {elapsed} seconds")
            analysis_selected_df = sel_df
            analysis_top_df = top_df
            analysis_elapsed = elapsed
            analysis_in_progress = False
            print("Worker thread finished, in_progress=False")
        except Exception as e:
            print(f"Error in analysis: {str(e)}")
            analysis_in_progress = False
            raise

    analysis_thread = threading.Thread(target=worker, daemon=True)
    analysis_thread.start()
    return "OK"  # Added return statement

@app.route('/analysis_progress', methods=['GET'])
def analysis_progress():
    global analysis_in_progress, analysis_elapsed
    resp = {
        'in_progress': analysis_in_progress and not analysis_cancel_requested,
        'done': (not analysis_in_progress) and (analysis_elapsed is not None),
        'elapsed': analysis_elapsed
    }
    return jsonify(resp)

@app.route('/download_top_csv', methods=['GET'])
def download_top_csv():
    global analysis_top_df
    if analysis_top_df is None:
        return "No analysis run yet", 400

    # Create a copy to avoid modifying the original DataFrame
    df_to_save = analysis_top_df.copy()

    # For chain analysis (l=-1), rename columns and drop 'Draw Count'
    if 'Offset' in df_to_save.columns:  # This indicates it's chain analysis
        df_to_save = df_to_save.drop('Draw Count', axis=1)
        df_to_save = df_to_save.rename(columns={
            'Offset': 'Analysis #',
            'Average Rank': 'Avg Rank',
            'MinValue': 'Min Rank',
            'Draws Until Common Subset': 'Top-Ranked Duration',
            'Analysis Start Draw': 'For Draw'
        })
        # Reorder columns to put 'For Draw' as second column
        df_to_save = df_to_save.reindex(columns=[
            'Analysis #',
            'For Draw',
            'Combination',
            'Avg Rank',
            'Min Rank',
            'Top-Ranked Duration',
            'Subsets'
        ])
    else:
        df_to_save = df_to_save.rename(columns={
            'Average Rank': 'Avg Rank',
            'MinValue': 'Min Rank'
        })
    output = io.StringIO()
    df_to_save.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=top_combinations.csv"
    response.headers["Content-type"] = "text/csv"
    return response

@app.route('/download_selected_csv', methods=['GET'])
def download_selected_csv():
    """
    Let users download the 'selected combos' (non-overlapping subsets) as CSV,
    matching the original code's functionality.
    """
    global analysis_selected_df
    if analysis_selected_df is None:
        return "No analysis run yet", 400

    # Create a copy to avoid modifying the original DataFrame
    df_to_save_sel = analysis_selected_df.copy()

    # For chain analysis (l=-1), rename columns and drop 'Draw Count'
    if 'Offset' not in df_to_save_sel.columns:  # This indicates it's chain analysis
        df_to_save_sel = df_to_save_sel.rename(columns={
            'Average Rank': 'Avg Rank',
            'MinValue': 'Min Rank'
        })

    output = io.StringIO()
    df_to_save_sel.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=selected_combinations.csv"
    response.headers["Content-type"] = "text/csv"
    return response

if __name__ == '__main__':
    # Typically run with "python app.py" or "gunicorn app:app"
    port = int(os.environ.get("PORT", 10000))
    app.run(host='0.0.0.0', port=port, debug=False)

database.py
# database.py
"""
database.py
-----------
Provides database-related functions for storing and retrieving TOTO combos
and draws. Each game type (like '6_42') has its own SQLite database file
(e.g., 'toto_6_42_draws.db').

Key points:
-----------
1) get_db_connection(game_type) returns a sqlite3 connection to the
   corresponding DB, using row_factory for convenience.
2) renumber_all(game_type) reassigns 'sort_order' and 'draw_number' so that
   each row is ordered consistently. This is called after any insertion
   or reordering operation.
3) get_draws(...) fetches a chunk of draws in ascending order by sort_order,
   applying a limit and offset.
4) count_draws(...) gives the total count for pagination.
5) insert_draw(numbers, game_type, after_id) inserts a new draw,
   placing it after a given ID's sort_order if provided, then calls renumber_all.
6) delete_draws(ids, game_type) deletes draws by ID and calls renumber_all.
7) update_draw(...) updates a draw's numbers, clamping them to [1..max_number].
8) get_all_draws(...) fetches all draws to generate CSV for "Download All" feature.

No functional differences from your original code aside from ensuring
everything stays consistent with the new analysis code.
"""

import sqlite3
import pandas as pd
from config import Config

def get_db_connection(game_type='6_42'):
    db_path = Config.GAMES[game_type]['db_name']
    conn = sqlite3.connect(db_path, timeout=5)
    conn.row_factory = sqlite3.Row
    return conn

def renumber_all(game_type='6_42'):
    conn = get_db_connection(game_type)
    c = conn.cursor()
    rows = c.execute("SELECT id FROM draws ORDER BY sort_order").fetchall()
    for i, row in enumerate(rows, start=1):
        draw_number = f"{i:04d}"
        c.execute("UPDATE draws SET sort_order=?, draw_number=? WHERE id=?",
                  (i, draw_number, row['id']))
    conn.commit()
    conn.close()

def get_draws(game_type='6_42', limit=100, offset=0):
    conn = get_db_connection(game_type)
    draws = conn.execute(
        "SELECT * FROM draws ORDER BY sort_order LIMIT ? OFFSET ?",
        (limit, offset)
    ).fetchall()
    conn.close()
    return draws

def count_draws(game_type='6_42'):
    conn = get_db_connection(game_type)
    count = conn.execute("SELECT COUNT(*) as cnt FROM draws").fetchone()["cnt"]
    conn.close()
    return count

def insert_draw(numbers, game_type='6_42', after_id=None):
    numbers = clamp_numbers(numbers, game_type)
    conn = get_db_connection(game_type)
    c = conn.cursor()

    if after_id:
        row = c.execute("SELECT sort_order FROM draws WHERE id=?", (after_id,)).fetchone()
        if row:
            after_sort = row["sort_order"]
            c.execute("UPDATE draws SET sort_order = sort_order + 1 WHERE sort_order > ?", (after_sort,))
            new_sort_order = after_sort + 1
        else:
            max_so = c.execute("SELECT MAX(sort_order) FROM draws").fetchone()[0]
            new_sort_order = (max_so or 0) + 1
    else:
        max_so = c.execute("SELECT MAX(sort_order) FROM draws").fetchone()[0]
        new_sort_order = (max_so or 0) + 1

    draw_number = "temp"
    c.execute('''
        INSERT INTO draws (draw_number, number1, number2, number3, number4, number5, number6, sort_order)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (draw_number, *numbers, new_sort_order))
    conn.commit()
    conn.close()

    renumber_all(game_type)

def delete_draws(ids, game_type='6_42'):
    conn = get_db_connection(game_type)
    q_marks = ",".join("?" for _ in ids)
    sql = f"DELETE FROM draws WHERE id IN ({q_marks})"
    conn.execute(sql, ids)
    conn.commit()
    conn.close()
    renumber_all(game_type)

def update_draw(draw_id, numbers, game_type='6_42'):
    numbers = clamp_numbers(numbers, game_type)
    conn = get_db_connection(game_type)
    conn.execute('''
        UPDATE draws
        SET number1=?, number2=?, number3=?, number4=?, number5=?, number6=?
        WHERE id=?
    ''', (*numbers, draw_id))
    conn.commit()
    conn.close()

def get_all_draws(game_type='6_42'):
    conn = get_db_connection(game_type)
    rows = conn.execute("SELECT * FROM draws ORDER BY sort_order").fetchall()
    conn.close()
    return rows

def clamp_numbers(nums, game_type='6_42'):
    max_number = Config.GAMES[game_type]['max_number']
    cleaned = []
    for n in nums:
        if n is None:
            cleaned.append(None)
        else:
            if n < 1:
                n = 1
            if n > max_number:
                n = max_number
            cleaned.append(n)
    return cleaned

init_database.py
# init_database.py
import pandas as pd
import sqlite3
import sys
from config import Config

def init_db(game_type):
    game_config = Config.GAMES[game_type]
    max_number = game_config['max_number']
    conn = sqlite3.connect(game_config['db_name'])
    c = conn.cursor()

    c.execute('DROP TABLE IF EXISTS draws')

    max_number = game_config['max_number']
    c.execute(f'''
        CREATE TABLE draws (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            draw_number TEXT,
            number1 INTEGER CHECK (number1 IS NULL OR (number1 >= 1 AND number1 <= {max_number})),
            number2 INTEGER CHECK (number2 IS NULL OR (number2 >= 1 AND number2 <= {max_number})),
            number3 INTEGER CHECK (number3 IS NULL OR (number3 >= 1 AND number3 <= {max_number})),
            number4 INTEGER CHECK (number4 IS NULL OR (number4 >= 1 AND number4 <= {max_number})),
            number5 INTEGER CHECK (number5 IS NULL OR (number5 >= 1 AND number5 <= {max_number})),
            number6 INTEGER CHECK (number6 IS NULL OR (number6 >= 1 AND number6 <= {max_number})),
            sort_order INTEGER
        )
    ''')

    conn.commit()
    return conn

def load_csv_to_db(game_type):
    try:
        game_config = Config.GAMES[game_type]
        df = pd.read_csv(game_config['csv_file'], header=None)
        df = df.iloc[1:].reset_index(drop=True)
        df['draw_number'] = df.index.map(lambda x: f'{x+1:04d}')

        conn = init_db(game_type)
        cursor = conn.cursor()

        for index, row in df.iterrows():
            numbers = sorted(row.iloc[:6].astype(int).tolist())
            draw_number = row['draw_number']
            cursor.execute('''
                INSERT INTO draws (draw_number, number1, number2, number3, number4, number5, number6)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (draw_number, *numbers))

        cursor.execute("UPDATE draws SET sort_order = id")
        conn.commit()
        conn.close()

        print(f"Successfully loaded {len(df)} draws into {game_config['db_name']}")
        return True
    except Exception as e:
        print(f"Error: {str(e)}")
        return False

if __name__ == "__main__":
    for game_type in Config.GAMES:
        print(f"\nInitializing database for {Config.GAMES[game_type]['name']}...")
        success = load_csv_to_db(game_type)
        if not success:
            sys.exit(1)

config.py
# config.py (new file)
class Config:
    GAMES = {
        '6_42': {
            'name': 'Toto 6/42',
            'max_number': 42,
            'db_name': 'toto_6_42_draws.db',
            'csv_file': 'Toto_6_42_with_first_row.csv'
        },
        '6_49': {
            'name': 'Toto 6/49',
            'max_number': 49,
            'db_name': 'toto_6_49_draws.db',
            'csv_file': 'Toto_6_49_with_first_row.csv'
        }
    }

requirements.txt
gunicorn==21.2.0
Flask==2.2.2
pandas==1.5.3
statistics;python_version<"3.10"
seaborn==0.12.0
tqdm==4.66.1
Flask-Session==0.5.0
numpy==1.23.2
itsdangerous==2.0.0
Werkzeug==2.2.2
click==8.0.0
Jinja2==3.0.0
MarkupSafe==2.1.1

C_engine/src/analysis_engine.c
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>

#include "analysis_engine.h"

#define MAX_COMBO_STR 255
#define MAX_SUBSETS_STR 65535
#define MAX_ALLOWED_J 200
#define MAX_ALLOWED_OUT_LEN 1000000
#define MAX_NUMBERS 50
#define HASH_SIZE (1 << 24)  // 16M entries

typedef unsigned long long uint64;
typedef unsigned int uint32;

// ----------------------------------------------------------------------
// Internal data and lookups
// ----------------------------------------------------------------------
static uint64 nCk_table[MAX_NUMBERS][MAX_NUMBERS];
static int bit_count_table[256];
static int initialized = 0;

typedef struct {
    uint64* keys;     // Subset bit patterns
    int* values;      // Last occurrence
    int size;
    int capacity;
} SubsetTable;

/**
 * ComboStats holds the enumerated combo stats for the top-l searching.
 * 'pattern' is the bit pattern (1<<(num-1)) of the combo's numbers.
 */
typedef struct {
    uint64 pattern;   // bit pattern of combo
    double avg_rank;
    double min_rank;
    int combo[MAX_NUMBERS];
    int len;
} ComboStats;

// ----------------------------------------------------------------------
// Forward declarations
// ----------------------------------------------------------------------
static void init_tables();
static inline int popcount64(uint64 x);
static SubsetTable* create_subset_table(int max_entries);
static void free_subset_table(SubsetTable* table);
static inline uint32 hash_subset(uint64 pattern);
static inline void insert_subset(SubsetTable* table, uint64 pattern, int value);
static inline int lookup_subset(const SubsetTable* table, uint64 pattern);
static inline uint64 numbers_to_pattern(const int* numbers, int count);
static void process_draw(const int* draw, int draw_idx, int k, SubsetTable* table);
static void evaluate_combo(const int* combo, int j, int k, int total_draws,
                           const SubsetTable* table, ComboStats* stats);
static void format_combo(const int* combo, int len, char* out);
static void format_subsets(const int* combo, int j, int k, int total_draws,
                           const SubsetTable* table, char* out);

static AnalysisResultItem* run_standard_analysis(
    const int* sorted_draws_data,
    int use_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int max_number,
    int* out_len
);

static AnalysisResultItem* run_chain_analysis(
    const int* sorted_draws_data,
    int draws_count,
    int initial_offset,
    int j,
    int k,
    const char* m,
    int max_number,
    int* out_len
);

/**
 * run_analysis_c(...)
 * -------------------
 */
AnalysisResultItem* run_analysis_c(
    const char* game_type,
    int** draws,
    int draws_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int last_offset,
    int* out_len
) {
    *out_len = 0;
    if (j > MAX_ALLOWED_J) {
        return NULL;
    }
    init_tables();

    // Decide max_number from the game_type
    int max_number = (strstr(game_type, "6_49")) ? 49 : 42;
    if (draws_count < 1) {
        return NULL;
    }

    // Build a local "sorted_draws_data" array. Each draw is sorted ascending.
    // The DB supplies them oldest->newest in index 0..draws_count-1.
    // We'll keep that order: index 0 => oldest, index draws_count-1 => newest.
    int* sorted_draws_data = (int*)malloc(draws_count * 6 * sizeof(int));
    if (!sorted_draws_data) {
        return NULL;
    }
    for (int i = 0; i < draws_count; i++) {
        int temp[6];
        for (int z = 0; z < 6; z++) {
            temp[z] = draws[i][z];
        }
        // sort the 6 numbers
        for (int a = 0; a < 5; a++) {
            for (int b = a + 1; b < 6; b++) {
                if (temp[a] > temp[b]) {
                    int t = temp[a];
                    temp[a] = temp[b];
                    temp[b] = t;
                }
            }
        }
        for (int z = 0; z < 6; z++) {
            sorted_draws_data[i * 6 + z] = temp[z];
        }
    }

    // If l != -1, run the standard approach
    if (l != -1) {
        int use_count = draws_count - last_offset;
        if (use_count < 1) {
            free(sorted_draws_data);
            return NULL;
        }
        AnalysisResultItem* ret = run_standard_analysis(
            sorted_draws_data,
            use_count,
            j, k, m, l, n, max_number,
            out_len
        );
        free(sorted_draws_data);
        return ret;
    }

    // Otherwise, chain analysis
    AnalysisResultItem* chain_ret = run_chain_analysis(
        sorted_draws_data,
        draws_count,
        last_offset,
        j, k, m,
        max_number,
        out_len
    );
    free(sorted_draws_data);
    return chain_ret;
}

// ----------------------------------------------------------------------
// Standard top-l analysis (and up to n combos that do not overlap in k-subsets).
// ----------------------------------------------------------------------
static AnalysisResultItem* run_standard_analysis(
    const int* sorted_draws_data,
    int use_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int max_number,
    int* out_len
) {
    // 1) Build the subset table from the newest use_count draws
    SubsetTable* table = create_subset_table(HASH_SIZE);
    if (!table) return NULL;
    for (int i = 0; i < use_count; i++) {
        process_draw(&sorted_draws_data[i * 6], i, k, table);
    }

    // 2) Enumerate all j-combinations, find top-l. We'll store them in best_stats.
    // 2) Prepare shared and thread-local data structures
    ComboStats* best_stats = (ComboStats*)malloc(l * sizeof(ComboStats));
    if (!best_stats) {
        free_subset_table(table);
        return NULL;
    }
    memset(best_stats, 0, l * sizeof(ComboStats));

    AnalysisResultItem* results = (AnalysisResultItem*)calloc(l + n, sizeof(AnalysisResultItem));
    if (!results) {
        free(best_stats);
        free_subset_table(table);
        return NULL;
    }

    int filled = 0;  // shared counter for best_stats filling
    int error_occurred = 0;  // flag for allocation errors

    #pragma omp parallel
    {
        // Thread-local combo buffer
        int* curr_combo = NULL;
        ComboStats* thread_best = NULL;
        int thread_filled = 0;

        curr_combo = (int*)malloc(j * sizeof(int));
        if (!curr_combo) {
            #pragma omp atomic write
            error_occurred = 1;
        } else {
            thread_best = (ComboStats*)malloc(l * sizeof(ComboStats));
            if (!thread_best) {
                free(curr_combo);
                #pragma omp atomic write
                error_occurred = 1;
            } else {
                memset(thread_best, 0, l * sizeof(ComboStats));

                // Parallelize by first number
                #pragma omp for schedule(dynamic)
                for (int first = 1; first <= max_number - j + 1; first++) {
                    if (!error_occurred) {  // Check if any thread had allocation error
                        curr_combo[0] = first;
                        for (int i = 1; i < j; i++) {
                            curr_combo[i] = first + i;
                        }

                        while (1) {
                            ComboStats stats;
                            evaluate_combo(curr_combo, j, k, use_count, table, &stats);

                            // Update thread_best array
                            if (thread_filled < l) {
                                memcpy(&thread_best[thread_filled], &stats, sizeof(ComboStats));
                                thread_filled++;
                                // bubble up in thread_best
                                for (int i = thread_filled - 1; i > 0; i--) {
                                    int swap;
                                    if (strcmp(m, "avg") == 0) {
                                        // For 'avg': first by avg_rank, then by min_rank
                                        swap = (thread_best[i].avg_rank > thread_best[i - 1].avg_rank) ||
                                            (thread_best[i].avg_rank == thread_best[i - 1].avg_rank &&
                                                thread_best[i].min_rank > thread_best[i - 1].min_rank);
                                    } else {
                                        // For 'min': first by min_rank, then by avg_rank
                                        swap = (thread_best[i].min_rank > thread_best[i - 1].min_rank) ||
                                            (thread_best[i].min_rank == thread_best[i - 1].min_rank &&
                                                thread_best[i].avg_rank > thread_best[i - 1].avg_rank);
                                    }
                                    if (swap) {
                                        ComboStats tmp = thread_best[i];
                                        thread_best[i] = thread_best[i - 1];
                                        thread_best[i - 1] = tmp;
                                    } else {
                                        break;
                                    }
                                }
                            } else {
                                int should_replace = 0;
                                if (strcmp(m, "avg") == 0) {
                                    // For 'avg': first by avg_rank, then by min_rank
                                    should_replace = (stats.avg_rank > thread_best[l - 1].avg_rank) ||
                                                    (stats.avg_rank == thread_best[l - 1].avg_rank &&
                                                    stats.min_rank > thread_best[l - 1].min_rank);
                                } else {
                                    // For 'min': first by min_rank, then by avg_rank
                                    should_replace = (stats.min_rank > thread_best[l - 1].min_rank) ||
                                                    (stats.min_rank == thread_best[l - 1].min_rank &&
                                                    stats.avg_rank > thread_best[l - 1].avg_rank);
                                }
                                if (should_replace) {
                                    thread_best[l - 1] = stats;
                                    // bubble up
                                    for (int i = l - 1; i > 0; i--) {
                                        int should_bubble = 0;
                                        if (strcmp(m, "avg") == 0) {
                                            // For 'avg': first by avg_rank, then by min_rank
                                            should_bubble = (thread_best[i].avg_rank > thread_best[i - 1].avg_rank) ||
                                                        (thread_best[i].avg_rank == thread_best[i - 1].avg_rank &&
                                                        thread_best[i].min_rank > thread_best[i - 1].min_rank);
                                        } else {
                                            // For 'min': first by min_rank, then by avg_rank
                                            should_bubble = (thread_best[i].min_rank > thread_best[i - 1].min_rank) ||
                                                        (thread_best[i].min_rank == thread_best[i - 1].min_rank &&
                                                        thread_best[i].avg_rank > thread_best[i - 1].avg_rank);
                                        }
                                        if (should_bubble) {
                                            ComboStats tmp = thread_best[i];
                                            thread_best[i] = thread_best[i - 1];
                                            thread_best[i] = thread_best[i - 1];
                                            thread_best[i - 1] = tmp;
                                        } else {
                                            break;
                                        }
                                    }
                                }
                            }

                            // Next combo - Optimized combo generation
                            int pos = j - 1;
                            while (pos >= 0) {
                                curr_combo[pos]++;
                                if (curr_combo[pos] <= max_number - (j - 1 - pos)) {
                                    for (int x = pos + 1; x < j; ++x) {
                                        curr_combo[x] = curr_combo[x - 1] + 1;
                                    }
                                    break;
                                }
                                pos--;
                            }
                            if (pos < 0) break; // No more combinations
                        }
                    }
                }

                // Merge thread results into global best_stats
                #pragma omp critical
                {
                    // Merge thread_best into best_stats
                    for (int i = 0; i < thread_filled; i++) {
                        if (filled < l) {
                            memcpy(&best_stats[filled], &thread_best[i], sizeof(ComboStats));
                            filled++;
                        } else {
                            double val = (strcmp(m, "avg") == 0)
                                ? thread_best[i].avg_rank
                                : thread_best[i].min_rank;
                            double worst_val = (strcmp(m, "avg") == 0)
                                ? best_stats[l - 1].avg_rank
                                : best_stats[l - 1].min_rank;
                            if (val > worst_val) {
                                best_stats[l - 1] = thread_best[i];
                                // bubble up
                                for (int idx = l - 1; idx > 0; idx--) {
                                    double vcur = (strcmp(m, "avg") == 0)
                                        ? best_stats[idx].avg_rank
                                        : best_stats[idx].min_rank;
                                    double vprev = (strcmp(m, "avg") == 0)
                                        ? best_stats[idx - 1].avg_rank
                                        : best_stats[idx - 1].min_rank;
                                    if (vcur > vprev) {
                                        ComboStats tmp = best_stats[idx];
                                        best_stats[idx] = best_stats[idx - 1];
                                        best_stats[idx - 1] = tmp;
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (thread_best) free(thread_best);
        if (curr_combo) free(curr_combo);
    }

    if (error_occurred) {
        free(best_stats);
        free(results);
        free_subset_table(table);
        return NULL;
    }
    // 3) Now fill the top-l combos into results
    int top_count = (filled < l) ? filled : l;  // how many combos we actually have
    int results_count = 0;

    // Rebuild table once more just to format subsets easily
    // (Slight overhead, but simpler.)
    free_subset_table(table);
    table = create_subset_table(HASH_SIZE);
    for (int i = 0; i < use_count; i++) {
        process_draw(&sorted_draws_data[i * 6], i, k, table);
    }

    for (int i = 0; i < top_count; i++) {
        // fill results[i] with the i-th best combo
        format_combo(best_stats[i].combo, best_stats[i].len, results[results_count].combination);
        format_subsets(best_stats[i].combo, j, k, use_count, table, results[results_count].subsets);
        results[results_count].avg_rank = best_stats[i].avg_rank;
        results[results_count].min_value = best_stats[i].min_rank;
        results[results_count].is_chain_result = 0;
        results[results_count].draw_offset = 0;
        results[results_count].analysis_start_draw = 0;
        results[results_count].draws_until_common = 0;
        // Also store the bit pattern in the struct so we can check overlap later
        // We'll repurpose analysis_start_draw to store the pattern. But better is just to store it in an array:
        // Actually we'll store it in best_stats[i].pattern. Already there.
        results_count++;
    }

    // 4) If n > 0, find up to n combos from these top_count combos
    //    that do not share a k-subset among themselves. We do this
    //    by scanning in the same order as top-l, skipping overlaps.
    int second_table_count = 0;
    int* pick_indices = NULL;
    if (n > 0 && top_count > 0) {
        pick_indices = (int*)malloc(top_count * sizeof(int));
        memset(pick_indices, -1, top_count * sizeof(int));

        // The first chosen combo is always best_stats[0].
        int chosen = 0;
        pick_indices[chosen++] = 0;

        for (int i = 1; i < top_count && chosen < n; i++) {
            // check overlap with all chosen combos
            uint64 pat_i = best_stats[i].pattern;
            int overlap = 0;
            for (int c = 0; c < chosen; c++) {
                int idxC = pick_indices[c];
                uint64 pat_c = best_stats[idxC].pattern;
                // Overlap if popcount64(pat_i & pat_c) >= k
                uint64 inter = (pat_i & pat_c);
                if (popcount64(inter) >= k) {
                    overlap = 1;
                    break;
                }
            }
            if (!overlap) {
                pick_indices[chosen++] = i;
            }
        }
        second_table_count = chosen; // how many we picked
    }

    // Now fill those second-table combos in the same results array
    // right after the top-l combos
    // Each one gets subsets too, so we do the same table logic
    int bottom_start = results_count;
    for (int i = 0; i < second_table_count; i++) {
        int idx = pick_indices[i];
        format_combo(best_stats[idx].combo, best_stats[idx].len, results[bottom_start + i].combination);
        format_subsets(best_stats[idx].combo, j, k, use_count, table, results[bottom_start + i].subsets);
        results[bottom_start + i].avg_rank = best_stats[idx].avg_rank;
        results[bottom_start + i].min_value = best_stats[idx].min_rank;
        results[bottom_start + i].is_chain_result = 0;
        results[bottom_start + i].draw_offset = 0;
        results[bottom_start + i].analysis_start_draw = 0;
        results[bottom_start + i].draws_until_common = 0;
    }
    int total_used = results_count + second_table_count;
    *out_len = total_used;

    if (pick_indices) {
        free(pick_indices);
    }
    free_subset_table(table);
    free(best_stats);

    if (total_used == 0) {
        free(results);
        return NULL;
    }
    return results;
}

// ----------------------------------------------------------------------
// Chain analysis (l = -1).
// ----------------------------------------------------------------------
static AnalysisResultItem* run_chain_analysis(
    const int* sorted_draws_data,
    int draws_count,
    int initial_offset,
    int j,
    int k,
    const char* m,
    int max_number,
    int* out_len
) {
    // We'll store results in a dynamic array of size (initial_offset+2).
    // Each chain iteration yields 1 combo.
    AnalysisResultItem* chain_results = (AnalysisResultItem*)calloc(initial_offset + 2, sizeof(AnalysisResultItem));
    if (!chain_results) {
        *out_len = 0;
        return NULL;
    }

    // Precompute bit patterns for each draw (6 numbers => bit pattern).
    uint64* draw_patterns = (uint64*)malloc(draws_count * sizeof(uint64));
    if (!draw_patterns) {
        free(chain_results);
        *out_len = 0;
        return NULL;
    }
    for (int i = 0; i < draws_count; i++) {
        uint64 pat = 0ULL;
        for (int z = 0; z < 6; z++) {
            pat |= (1ULL << (sorted_draws_data[i * 6 + z] - 1));
        }
        draw_patterns[i] = pat;
    }

    int chain_index = 0;
    int current_offset = initial_offset;

    while (1) {
        if (current_offset < 0) {
            break;
        }
        if (current_offset > (draws_count - 1)) {
            // no valid draws to analyze
            break;
        }
        int use_count = draws_count - current_offset;
        if (use_count < 1) {
            break;
        }

        // Build subset table for newest use_count draws
        SubsetTable* table = create_subset_table(HASH_SIZE);
        for (int i = 0; i < use_count; i++) {
            process_draw(&sorted_draws_data[i * 6], i, k, table);
        }

        // We want top-1 combo under j,k,m
        int found_any = 0;
        double best_val = -1e9;
        ComboStats best_stat;
        memset(&best_stat, 0, sizeof(best_stat));

        // Enumerate
        int* combo_buf = (int*)malloc(j * sizeof(int));
        if (!combo_buf) {
            free_subset_table(table);
            break;
        }
        for (int i = 0; i < j; i++) {
            combo_buf[i] = i + 1;
        }

        while (1) {
            ComboStats stats;
            evaluate_combo(combo_buf, j, k, use_count, table, &stats);

            int is_better = 0;
            if (!found_any) {
                is_better = 1;
            } else if (strcmp(m, "avg") == 0) {
                // For 'avg': first by avg_rank, then by min_rank
                is_better = (stats.avg_rank > best_stat.avg_rank) ||
                            (stats.avg_rank == best_stat.avg_rank &&
                            stats.min_rank > best_stat.min_rank);
            } else {
                // For 'min': first by min_rank, then by avg_rank
                is_better = (stats.min_rank > best_stat.min_rank) ||
                            (stats.min_rank == best_stat.min_rank &&
                            stats.avg_rank > best_stat.avg_rank);
            }
            if (is_better) {
                best_stat = stats;
                found_any = 1;
            }

            // next - Optimized combo generation
            int pos = j - 1;
            while (pos >= 0) {
                combo_buf[pos]++;
                if (combo_buf[pos] <= max_number - (j - 1 - pos)) {
                    for (int x = pos + 1; x < j; ++x) {
                        combo_buf[x] = combo_buf[x - 1] + 1;
                    }
                    break;
                }
                pos--;
            }
            if (pos < 0) break;
        }
        free(combo_buf);
        free_subset_table(table);

        if (!found_any) {
            break;
        }

        // Fill chain_results item
        AnalysisResultItem* out_item = &chain_results[chain_index];
        format_combo(best_stat.combo, best_stat.len, out_item->combination);

        // Build a subsets string for display
        {
            SubsetTable* tmp_t = create_subset_table(HASH_SIZE);
            for (int i = 0; i < use_count; i++) {
                process_draw(&sorted_draws_data[i * 6], i, k, tmp_t);
            }
            format_subsets(best_stat.combo, j, k, use_count, tmp_t, out_item->subsets);
            free_subset_table(tmp_t);
        }
        out_item->avg_rank = best_stat.avg_rank;
        out_item->min_value = best_stat.min_rank;
        out_item->is_chain_result = 1;
        out_item->draw_offset = chain_index + 1;  // "Analysis #"
        out_item->analysis_start_draw = draws_count - current_offset;  // "For Draw"

        // Now find forward draws that share a k-subset
        // with the best_stat combo
        uint64 combo_pat = 0ULL;
        for (int z = 0; z < j; z++) {
            combo_pat |= (1ULL << (best_stat.combo[z] - 1));
        }

        int found_common = 0;
        int i;
        for (i = 1; i <= current_offset; i++) {
            int f_idx = draws_count - 1 - (current_offset - i);
            if (f_idx < 0) break;
            uint64 fpat = draw_patterns[f_idx];
            uint64 inter = (combo_pat & fpat);
            if (popcount64(inter) >= k) {
                found_common = 1;
                break;
            }
        }
        // If not found, pretend we found it after current_offset + 1
        if (!found_common) {
            i = current_offset + 1;
        } else if (i > current_offset) {
            i = current_offset;
        }

        out_item->draws_until_common = (i > 0) ? (i - 1) : 0;
        current_offset -= i;
        chain_index++;

        if (current_offset <= 0) {
            break;
        }
    }

    free(draw_patterns);
    *out_len = chain_index;
    if (chain_index == 0) {
        free(chain_results);
        return NULL;
    }
    return chain_results;
}

/**
 * free_analysis_results(...)
 */
void free_analysis_results(AnalysisResultItem* results) {
    if (results) {
        free(results);
    }
}

// ----------------------------------------------------------------------
// Implementation details
// ----------------------------------------------------------------------
static void init_tables() {
    if (initialized) return;
    memset(nCk_table, 0, sizeof(nCk_table));
    for (int n = 0; n < MAX_NUMBERS; n++) {
        nCk_table[n][0] = 1;
        for (int k = 1; k <= n; k++) {
            nCk_table[n][k] = nCk_table[n-1][k-1] + nCk_table[n-1][k];
        }
    }
    // bit counts
    for (int i = 0; i < 256; i++) {
        int c = 0;
        for (int b = 0; b < 8; b++) {
            if (i & (1 << b)) c++;
        }
        bit_count_table[i] = c;
    }
    initialized = 1;
}

static inline int popcount64(uint64 x) {
    return __builtin_popcountll(x); // Use built-in for speed
}

static SubsetTable* create_subset_table(int max_entries) {
    SubsetTable* t = (SubsetTable*)malloc(sizeof(SubsetTable));
    if (!t) return NULL;
    t->size = 0;
    t->capacity = max_entries;
    t->keys = (uint64*)calloc(max_entries, sizeof(uint64));
    t->values = (int*)malloc(max_entries * sizeof(int));
    if (!t->keys || !t->values) {
        free(t->keys);
        free(t->values);
        free(t);
        return NULL;
    }
    for (int i = 0; i < max_entries; i++) {
        t->values[i] = -1;
    }
    return t;
}

static void free_subset_table(SubsetTable* table) {
    if (!table) return;
    free(table->keys);
    free(table->values);
    free(table);
}

static inline uint32 hash_subset(uint64 pattern) {
    // Simple 64->32 hash - just use lower 32 bits for speed
    return (uint32)(pattern & (HASH_SIZE - 1));
}

static inline void insert_subset(SubsetTable* table, uint64 pattern, int value) {
    uint32 idx = hash_subset(pattern);
    while (1) {
        if (table->values[idx] == -1 || table->keys[idx] == pattern) {
            table->keys[idx] = pattern;
            table->values[idx] = value;
            return;
        }
        idx = (idx + 1) & (HASH_SIZE - 1);
    }
}

static inline int lookup_subset(const SubsetTable* table, uint64 pattern) {
    uint32 idx = hash_subset(pattern);
    while (1) {
        if (table->values[idx] == -1) return -1;
        if (table->keys[idx] == pattern) return table->values[idx];
        idx = (idx + 1) & (HASH_SIZE - 1);
    }
}

static inline uint64 numbers_to_pattern(const int* numbers, int count) {
    uint64 p = 0ULL;
    for (int i = 0; i < count; i++) {
        p |= (1ULL << (numbers[i] - 1));
    }
    return p;
}

static void process_draw(const int* draw, int draw_idx, int k, SubsetTable* table) {
    if (k > 6) return;
    int idx[6]; // Optimized index array size
    for (int i = 0; i < k; i++) {
        idx[i] = i;
    }
    while (1) {
        uint64 pat = 0ULL;
        for (int i = 0; i < k; i++) {
            pat |= (1ULL << (draw[idx[i]] - 1));
        }
        insert_subset(table, pat, draw_idx);

        // Optimized next combination generation
        int pos = k - 1;
        while (pos >= 0) {
            idx[pos]++;
            if (idx[pos] <= 6 - (k - 1 - pos)) {
                for (int x = pos + 1; x < k; ++x) {
                    idx[x] = idx[x - 1] + 1;
                }
                break;
            }
            pos--;
        }
        if (pos < 0) break;
    }
}

static void evaluate_combo(const int* combo, int j, int k, int total_draws,
                           const SubsetTable* table, ComboStats* stats)
{
    double sum_ranks = 0.0;
    double min_rank = (double)total_draws;
    int count = 0;

    int idx[6]; // Optimized index array size
    for (int i = 0; i < k; i++) {
        idx[i] = i;
    }

    while (1) {
        uint64 pat = 0ULL;
        for (int i = 0; i < k; i++) {
            pat |= (1ULL << (combo[idx[i]] - 1));
        }
        int last_seen = lookup_subset(table, pat);
        double rank = (last_seen >= 0)
                      ? (double)(total_draws - last_seen - 1)
                      : (double)total_draws;
        sum_ranks += rank;
        if (rank < min_rank) {
            min_rank = rank;
        }
        count++;

        // Optimized next combination generation
        int pos = k - 1;
        while (pos >= 0) {
            idx[pos]++;
            if (idx[pos] <= j - (k - 1 - pos)) {
                for (int x = pos + 1; x < k; ++x) {
                    idx[x] = idx[x - 1] + 1;
                }
                break;
            }
            pos--;
        }
        if (pos < 0) break;
    }

    stats->pattern = numbers_to_pattern(combo, j);
    stats->avg_rank = sum_ranks / (double)count;
    stats->min_rank = min_rank;
    memcpy(stats->combo, combo, j * sizeof(int));
    stats->len = j;
}

static void format_combo(const int* combo, int len, char* out) {
    int pos = 0;
    for (int i = 0; i < len; i++) {
        if (i > 0) {
            out[pos++] = ',';
            out[pos++] = ' ';
        }
        pos += sprintf(out + pos, "%d", combo[i]);
    }
    out[pos] = '\0';
}

static void format_subsets(const int* combo, int j, int k, int total_draws,
                          const SubsetTable* table, char* out) {
    typedef struct {
        int numbers[6];  // Optimized index array size
        int rank;
    } SubsetInfo;

    const int BUFFER_SIZE = 65535;  // Leave 1 byte for null terminator

    int exact_subset_count = (int)nCk_table[j][k];

    SubsetInfo* subsets = (SubsetInfo*)malloc(exact_subset_count * sizeof(SubsetInfo));
    if (!subsets) {
        strcpy(out, "[]");
        return;
    }
    int subset_count = 0;

    int idx[6];  // Optimized index array size
    for (int i = 0; i < k; i++) {
        idx[i] = i;
    }

    while (1) {
        if (subset_count >= exact_subset_count) break;

        for (int i = 0; i < k; i++) {
            subsets[subset_count].numbers[i] = combo[idx[i]];
        }

        uint64 pat = 0ULL;
        for (int i = 0; i < k; i++) {
            pat |= (1ULL << (combo[idx[i]] - 1));
        }
        int last_seen = lookup_subset(table, pat);
        int rank = (last_seen >= 0)
                   ? (total_draws - last_seen - 1)
                   : total_draws;
        subsets[subset_count].rank = rank;
        subset_count++;

        // Optimized next combination generation
        int p = k - 1;
        while (p >= 0) {
            idx[p]++;
            if (idx[p] <= j - (k - 1 - p)) {
                for (int x = p + 1; x < k; ++x) {
                    idx[x] = idx[x - 1] + 1;
                }
                break;
            }
            pos--;
        }
        if (pos < 0) break;
    }

    for (int i = 0; i < subset_count - 1; i++) {
        for (int j = i + 1; j < subset_count; j++) {
            if (subsets[j].rank > subsets[i].rank) {
                SubsetInfo temp = subsets[i];
                subsets[i] = subsets[j];
                subsets[j] = temp;
            }
        }
    }

    int remaining_space = BUFFER_SIZE;
    int pos = 0;

    out[pos++] = '[';
    remaining_space--;

    for (int i = 0; i < subset_count && remaining_space > 0; i++) {
        if (i > 0) {
            if (remaining_space < 2) break;
            out[pos++] = ',';
            out[pos++] = ' ';
            remaining_space -= 2;
        }

        char subset_buffer[256];
        int subset_len = snprintf(subset_buffer, sizeof(subset_buffer),
                                "((%d", subsets[i].numbers[0]);
        for (int n = 1; n < k; n++) {
            subset_len += snprintf(subset_buffer + subset_len,
                                 sizeof(subset_buffer) - subset_len,
                                 ", %d", subsets[i].numbers[n]);
        }
        subset_len += snprintf(subset_buffer + subset_len,
                             sizeof(subset_buffer) - subset_len,
                             "), %d)", subsets[i].rank);

        if (subset_len >= remaining_space) break;

        memcpy(out + pos, subset_buffer, subset_len);
        pos += subset_len;
        remaining_space -= subset_len;
    }

    if (remaining_space > 0) {
        out[pos++] = ']';
    } else {
        out[BUFFER_SIZE-1] = ']';
        pos = BUFFER_SIZE;
    }
    out[pos] = '\0';

    free(subsets);
}

C_engine/src/analysis_engine.h
#ifndef ANALYSIS_ENGINE_H
#define ANALYSIS_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

/**
 * AnalysisResultItem
 * ------------------
 * Holds a single analysis result, whether from standard top-l
 * or from chain analysis (l == -1).
 */
typedef struct {
    char combination[256];
    double avg_rank;
    double min_value;
    char subsets[65536];

    // For chain analysis:
    //   draw_offset: "Analysis #"
    //   draws_until_common: "Top-Ranked Duration"
    //   analysis_start_draw: "For Draw" ( = total_draws - offset )
    //   is_chain_result: 1 if from chain analysis
    int draw_offset;
    int draws_until_common;
    int analysis_start_draw;
    int is_chain_result;
} AnalysisResultItem;

/**
 * run_analysis_c(...)
 * -------------------
 * Main entry point for both standard (l >= 1) and chain (l == -1) analyses.
 *
 * If l != -1, returns up to l + n combos (the top-l plus optional selected combos),
 * but the selected combos are now chosen to avoid overlapping *k*-subsets with each other.
 *
 * If l == -1, runs the chain of repeated top-1 analyses:
 *   - Each iteration uses the current offset.
 *   - After each top-1 result, searches forward draws for a common k-subset.
 *     If never found, we imagine a future draw to finalize Top-Ranked Duration.
 *
 * Caller must free the returned pointer with free_analysis_results(...).
 *
 * out_len is set to the number of AnalysisResultItem results.
 *
 * Returns NULL if no results (out_len=0).
 */
AnalysisResultItem* run_analysis_c(
    const char* game_type,
    int** draws,
    int draws_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int last_offset,
    int* out_len
);

/**
 * free_analysis_results(...)
 * --------------------------
 * Frees the array returned by run_analysis_c.
 */
void free_analysis_results(AnalysisResultItem* results);

#ifdef __cplusplus
}
#endif

#endif

</current_code>

<context>
This is my toto project. It runs very fast for parameters 6 and 3, e.g. but when I run it with 9 and 3, e.g. it runs for 3 - 4 minutes for 6/42. If I run it for 10 and 3 and above it becomes useless due to being very slow. I want to run it for parameters up to 15 and 4, e.g., and get the results but it's utterly impossible. I tried it once but it couldn't finish for 3 days on full capacity of my laptop and I had to stop it.
</context>

<goals>
Make the program finish few orders of magnitude faster.
</goals>

<constraints>
The outputs must be unchanged.
</constraints>

After you are done, generate only the files you made changes to. The complete code should be generated, i.e. you should use no placeholders. Think harder about any question that might need a little more brain power.

