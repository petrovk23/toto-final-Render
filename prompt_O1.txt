<current_code>

Procfile
web: gunicorn app:app

static/css/custom.css
/* static/css/custom.css */
table#combos-table tr.selected {
    background-color: #ffb347 !important;
    color: #000 !important;
    font-weight: bold;
}

static/js/main.js
// static/js/main.js
// This file can remain empty now since all Handsontable logic moved into combos.html

templates/game_options.html
{% extends "layout_no_sidebar.html" %}

{% block content %}
<div class="text-center">
    <h2>{{ game_config.name }} Options</h2>
    <div class="row mt-4 justify-content-center">
        <div class="col-md-5">
            <div class="card mb-4">
                <div class="card-header">
                    <h5>View/Edit Combinations</h5>
                </div>
                <div class="card-body">
                    <p>Browse, edit, and manage existing combinations for {{ game_config.name }}.</p>
                    <a href="{{ url_for('combos') }}" class="btn btn-primary">View Combos</a>
                </div>
            </div>
        </div>
        <div class="col-md-5">
            <div class="card mb-4">
                <div class="card-header">
                    <h5>Run Analysis</h5>
                </div>
                <div class="card-body">
                    <p>Perform advanced analysis on combinations for {{ game_config.name }}.</p>
                    <a href="{{ url_for('analysis_start') }}" class="btn btn-success">Start Analysis</a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

templates/combos.html
{% extends "layout.html" %}

{% block sidebar %}
<h5 class="mt-3">Combos Navigation</h5>
<div class="mb-2 d-flex justify-content-between">
    <button onclick="goTop()" class="btn btn-secondary">Top</button>
    <button class="btn btn-secondary" onclick="pageUp()">Page Up</button>
</div>
<div class="mb-2 d-flex justify-content-between">
    <button class="btn btn-secondary" onclick="bottom()">Bottom</button>
    <button class="btn btn-secondary" onclick="pageDown()">Page Down</button>
</div>

<form method="get" action="{{ url_for('combos') }}" class="mb-2">
    <div class="mb-2">
        <label>Page Size:</label>
        <input type="number" name="limit" value="{{ limit|default(20) }}" class="form-control">
    </div>
    <div class="mb-2">
        <label>Current Offset:</label>
        <input type="number" name="offset" value="{{ offset }}" class="form-control">
    </div>
    <button type="submit" class="btn btn-primary">Go</button>
</form>

<hr>

<a href="{{ url_for('download_all_combos') }}" class="btn btn-info mb-2">Download All as CSV</a>

{% endblock sidebar %}

{% block content %}
<h2>Existing Combos</h2>
<p>Total Count: <span id="total-count">{{ total_count }}</span></p>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@11.1.0/dist/handsontable.full.min.css">
<script src="https://cdn.jsdelivr.net/npm/handsontable@11.1.0/dist/handsontable.full.min.js"></script>

<div id="hot" style="width:100%; height:600px; overflow:auto;"></div>

<script>
let total_count = {{ total_count }};
let limit = parseInt('{{ limit|default(20) }}', 10);
let offset = parseInt('{{ offset }}', 10);

function updateTotalCount(delta) {
    total_count += delta;
    document.getElementById('total-count').textContent = total_count;
}

function navigate(o) {
    window.location.href = '{{ url_for("combos") }}?limit=' + limit + '&offset=' + o;
}
function goTop(){ navigate(0); }
function pageUp() {
    let newOffset = offset - limit;
    if (newOffset < 0) newOffset = 0;
    navigate(newOffset);
}
function bottom() {
    let newOffset = total_count - limit;
    if (newOffset < 0) newOffset = 0;
    navigate(newOffset);
}
function pageDown() {
    let newOffset = offset + limit;
    navigate(newOffset);
}

const container = document.getElementById('hot');
let hot;
let loading = false;

function loadData() {
  loading = true;
  fetch('/combos_data?limit=' + limit + '&offset=' + offset)
    .then(response => response.json())
    .then(data => {
      hot.loadData(data);
      loading = false;
    });
}

hot = new Handsontable(container, {
  data: [],
  colHeaders: ["Draw", "#1", "#2", "#3", "#4", "#5", "#6", "ID"],
  columns: [
    { data: 0, readOnly: true },
    { data: 1, type: 'numeric' },
    { data: 2, type: 'numeric' },
    { data: 3, type: 'numeric' },
    { data: 4, type: 'numeric' },
    { data: 5, type: 'numeric' },
    { data: 6, type: 'numeric' },
    { data: 7, readOnly: true }  // hidden ID
  ],
  hiddenColumns: {
    columns: [7],
    indicators: false
  },
  rowHeaders: true,
  manualRowMove: true,
  copyPaste: true,
  contextMenu: {
    items: {
      "row_above": { name: "Insert row above" },
      "row_below": { name: "Insert row below" },
      "remove_row": { name: "Remove row" },
      "copy": { name: "Copy" },
      "paste": {
        name: "Paste",
        callback: async function() {
          try {
            const text = await navigator.clipboard.readText();
            if (!text) return;
            const cpPlugin = this.getPlugin('CopyPaste');
            cpPlugin.paste(text);
          } catch (err) {
            console.error("Error reading clipboard:", err);
            alert("Unable to paste. Your browser may require HTTPS or permission for clipboard access.");
          }
        }
      }
    }
  },
  licenseKey: 'non-commercial-and-evaluation'
});

let rowsToRemoveIDs = [];

hot.addHook('beforeRemoveRow', (index, amount) => {
  rowsToRemoveIDs = [];
  for (let i = 0; i < amount; i++) {
    const rowData = hot.getDataAtRow(index + i);
    if (rowData && rowData[7] != null) {
      rowsToRemoveIDs.push(rowData[7]);
    }
  }
});

hot.addHook('afterRemoveRow', (index, amount, source) => {
  if (rowsToRemoveIDs.length > 0) {
    const formData = new URLSearchParams();
    rowsToRemoveIDs.forEach(id => formData.append('ids[]', id));

    fetch('/delete_combos_hot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: formData
    })
    .then(r => {
      if (!r.ok) {
        alert("Error deleting combos");
      } else {
        updateTotalCount(-amount);
        loadData();
      }
    });
  } else {
    loadData();
  }
});

hot.addHook('afterCreateRow', (index, amount, source) => {
  let after_id = null;
  if (index > 0) {
    const prevRow = hot.getDataAtRow(index - 1);
    if (prevRow && prevRow[7] != null) {
      after_id = prevRow[7];
    }
  }
  fetch('/add_combo_hot', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ after_id: after_id || '' })
  }).then(r => {
    if (!r.ok) {
      alert("Invalid combo insert");
    } else {
      updateTotalCount(1);
      loadData();
    }
  });
});

hot.addHook('afterRowMove', (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {
  if (!orderChanged) return;
  const allData = hot.getData();
  const idsOrder = allData.map(r => r[7]).filter(x => x != null);
  const formData = new URLSearchParams();
  idsOrder.forEach(id => formData.append('new_order[]', id));

  fetch('/move_row_hot', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: formData
  }).then(r => {
    if (!r.ok) {
      alert("Error moving row");
    } else {
      loadData();
    }
  });
});

hot.addHook('afterChange', (changes, source) => {
  if (!changes || loading) return;
  if (source === 'loadData') return;

  const changedRows = new Set();
  changes.forEach(([row, prop, oldVal, newVal]) => {
    if (oldVal !== newVal) {
      changedRows.add(row);
    }
  });
  if (changedRows.size === 0) return;

  let promises = [];
  changedRows.forEach(rowIndex => {
    const rowData = hot.getDataAtRow(rowIndex);
    const draw_id = rowData[7];
    if (draw_id != null) {
      const nums = {
        id: draw_id,
        num1: rowData[1],
        num2: rowData[2],
        num3: rowData[3],
        num4: rowData[4],
        num5: rowData[5],
        num6: rowData[6]
      };
      promises.push(
        fetch('/update_combo_hot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams(nums)
        })
        .then(resp => {
          if (!resp.ok) alert("Invalid combo update");
        })
      );
    }
  });

  Promise.all(promises).then(() => loadData());
});

loadData();
</script>

{# Removed the "Back to Options" button from here. The link is now in the top ribbon. #}

{% endblock content %}

templates/index.html
{% extends "layout_no_sidebar.html" %}

{% block content %}
<div class="text-center">
    <h2>Toto Combinations Analyzer</h2>
    <div class="row mt-4">
        <div class="col-md-6 offset-md-3">
            <div class="card">
                <div class="card-header">
                    <h5>Select Game</h5>
                </div>
                <div class="card-body">
                    <div class="list-group">
                        {% for game_type, config in games.items() %}
                        <a href="{{ url_for('select_game', game_type=game_type) }}" class="list-group-item list-group-item-action">
                            {{ config.name }}
                        </a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

templates/layout.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Toto Combinations Analyzer</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/custom.css') }}">

    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <style>
        .sidebar {
            position: sticky;
            top: 0;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            padding: 1rem;
        }
        #combos-table thead th {
            position: sticky;
            top: 0;
            background: #ffffff;
            z-index: 10;
        }
        @media (min-width: 768px) {
            .sidebar {
                width: 250px;
            }
        }
        .main-content {
            flex-grow: 1;
        }
    </style>
</head>
<body class="bg-light">
    <!-- Navbar with brand (left), game label (center), back link (right) -->
    <nav class="navbar navbar-dark bg-dark mb-3">
        <div class="container-fluid d-flex justify-content-between align-items-center">

            <!-- Left: brand -->
            <a class="navbar-brand" href="{{ url_for('index') }}">
                Toto Combinations Analyzer
            </a>

            <!-- Center: game label (if any) -->
            <div class="text-light text-center flex-fill">
                {% if session.get('game_type') %}
                    <span style="font-weight: 500;">
                        {{ config.GAMES[session.get('game_type')]['name'] }}
                    </span>
                {% endif %}
            </div>

            <!-- Right: back link logic -->
            <div class="d-flex align-items-center">
                {% if request.endpoint == 'index' %}
                    <!-- On the index page, no back link -->

                {% elif request.endpoint == 'select_game' %}
                    <!-- On the select_game page, link back to index -->
                    <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                        Back to Game Selection
                    </a>

                {% else %}
                    {% if session.get('game_type') %}
                        <a href="{{ url_for('select_game', game_type=session['game_type']) }}"
                           class="btn btn-outline-light">
                            Back to Options
                        </a>
                    {% else %}
                        <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                            Back to Game Selection
                        </a>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Left Pane (sidebar) -->
            <div class="col-12 col-md-3 col-lg-2 sidebar">
                {% block sidebar %}{% endblock sidebar %}
            </div>

            <!-- Main Content -->
            <div class="col-12 col-md-9 col-lg-10 p-4 main-content">
                {% block content %}{% endblock content %}
            </div>
        </div>
    </div>
</body>
</html>

templates/layout_no_sidebar.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Toto Combinations Analyzer</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/custom.css') }}">

    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <style>
        /* We remove the sidebar entirely */
        .main-centered {
            display: flex;
            justify-content: center;
        }
        .content-wrapper {
            max-width: 900px; /* adjustable */
            width: 100%;
        }
    </style>
</head>
<body class="bg-light">
    <!-- Navbar with brand (left), game label (center), back link (right) -->
    <nav class="navbar navbar-dark bg-dark mb-3">
        <div class="container-fluid d-flex justify-content-between align-items-center">

            <!-- Left: brand -->
            <a class="navbar-brand" href="{{ url_for('index') }}">
                Toto Combinations Analyzer
            </a>

            <!-- Right: back link logic -->
            <div class="d-flex align-items-center">
                {% if request.endpoint == 'index' %}
                    <!-- On the index page, no back link -->

                {% elif request.endpoint == 'select_game' %}
                    <!-- On the select_game page, link back to index -->
                    <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                        Back to Game Selection
                    </a>

                {% else %}
                    {% if session.get('game_type') %}
                        <a href="{{ url_for('select_game', game_type=session['game_type']) }}"
                           class="btn btn-outline-light">
                            Back to Options
                        </a>
                    {% else %}
                        <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                            Back to Game Selection
                        </a>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </nav>

    <!-- Single-column, centered content -->
    <div class="container main-centered">
        <div class="content-wrapper">
            {% block content %}{% endblock content %}
        </div>
    </div>
</body>
</html>

templates/results.html
{% extends "layout.html" %}

{% block content %}
<h4>Toto Combinations Analyzer</h4>

{% if selected_df is none and top_df is none %}
<div class="alert alert-info">
    <p>Ready to run analysis. Adjust parameters and click "Run Analysis".</p>
</div>
{% endif %}

<div id="analysis-progress-container" style="display: none;" class="mt-2">
    <div class="d-flex align-items-center">
        <div class="spinner-border spinner-border-sm text-primary me-2" role="status" id="analysis-spinner"></div>
        <small id="analysis-status-text">Processing...</small>
    </div>
    <div class="progress mt-2" style="height: 4px;">
        <div class="progress-bar" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100" id="analysis-progress-bar"></div>
    </div>
    <small class="text-muted" id="analysis-progress-detail"></small>
</div>

<hr class="my-2">

<div id="results-container">
    {% if top_df is not none %}
    <small class="text-muted">Completed in {{ elapsed }} seconds.</small>

    <h6 class="mt-3 mb-2">{% if l == -1 %}Analysis Chain Results:{% else %}Top-ranked combinations:{% endif %}</h6>
    <table class="table table-sm table-striped table-hover">
        <thead>
            <tr>
                {% if l == -1 %}
                <th style="width: 100px;">Analysis #</th>
                <th style="width: 100px;">For Draw</th>
                {% endif %}
                <th style="width: 180px;">Combination</th>
                <th style="width: 100px;">Avg Rank</th>
                <th style="width: 100px;">Min Rank</th>
                {% if l == -1 %}
                <th style="width: 180px;">Top-Ranked Duration</th>
                {% endif %}
                <th>Subsets <small class="text-muted">(click to expand)</small></th>
            </tr>
        </thead>
        <tbody>
        {% for idx, row in top_df.iterrows() %}
            <tr>
                {% if l == -1 %}
                <td>{{ idx + 1 }}</td>
                <td>{{ row['Analysis Start Draw'] }}</td>
                {% endif %}
                <td>{{ row['Combination'] }}</td>
                <td>{{ "%.2f"|format(row['Average Rank']) }}</td>
                <td>{{ row['MinValue'] }}</td>
                {% if l == -1 %}
                <td>{{ row['Draws Until Common Subset'] }}</td>
                {% endif %}
                <td class="subset-cell">
                    <span class="subset-preview">{{ row['Subsets'][:50] }}...</span>
                    <span class="subset-full" style="display: none;">{{ row['Subsets'] }}</span>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>

    <a href="{{ url_for('download_top_csv') }}" class="btn btn-info btn-sm">Download Top CSV</a>

    {% if selected_df is not none %}
    <h6 class="mt-4 mb-2">Top-ranked combinations w/o overlapping subsets:</h6>
    <table class="table table-sm table-striped table-hover">
        <thead>
            <tr>
                <th style="width: 180px;">Combination</th>
                <th style="width: 100px;">Avg Rank</th>
                <th style="width: 100px;">Min Rank</th>
                <th>Subsets <small class="text-muted">(click to expand)</small></th>
            </tr>
        </thead>
        <tbody>
        {% for idx, row in selected_df.iterrows() %}
            <tr>
                <td>{{ row['Combination'] }}</td>
                <td>{{ "%.2f"|format(row['Average Rank']) }}</td>
                <td>{{ row['MinValue'] }}</td>
                <td class="subset-cell">
                    <span class="subset-preview">{{ row['Subsets'][:50] }}...</span>
                    <span class="subset-full" style="display: none;">{{ row['Subsets'] }}</span>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
    <a href="{{ url_for('download_selected_csv') }}" class="btn btn-info btn-sm">Download Selected CSV</a>
    {% endif %}
    {% endif %}
</div>

<style>
.table { margin-bottom: 0.5rem; }
.table td, .table th { padding: 0.25rem 0.5rem; }
.subset-cell {
    cursor: pointer;
    font-size: 12px;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.subset-cell:hover {
    background-color: #f8f9fa;
}
.subset-cell.expanded {
    max-width: none;
    white-space: normal;
    word-break: break-all;
}
.subset-preview, .subset-full {
    font-family: monospace;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const runBtn = document.getElementById('run-analysis-btn');
    const progressContainer = document.getElementById('analysis-progress-container');
    const progressBar = document.getElementById('analysis-progress-bar');
    const statusText = document.getElementById('analysis-status-text');
    const progressDetail = document.getElementById('analysis-progress-detail');
    const resultsContainer = document.getElementById('results-container');

    let pollInterval = null;

    function createParams() {
        const params = new URLSearchParams();
        const offsetEl = document.getElementById('param-offset-last');
        let offsetVal = offsetEl ? offsetEl.value : "0";

        params.append('offset_last', offsetVal);
        params.append('j', document.getElementById('param-j').value);
        params.append('k', document.getElementById('param-k').value);
        params.append('m', document.getElementById('param-m').value);
        params.append('l', document.getElementById('param-l').value);
        params.append('n', document.getElementById('param-n').value);
        return params;
    }

    function startAnalysis() {
        resultsContainer.style.display = 'none';
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressDetail.textContent = '';
        statusText.textContent = 'Processing...';

        fetch('/analysis_run', {
            method: 'POST',
            body: createParams()
        })
        .then(resp => {
            if (!resp.ok) throw new Error('Failed to start analysis');
            if (pollInterval) clearInterval(pollInterval);
            pollInterval = setInterval(checkProgress, 1000);
        })
        .catch(err => {
            alert("Failed to start analysis: " + err.message);
        });
    }

    function checkProgress() {
        fetch('/analysis_progress')
        .then(resp => {
            if (!resp.ok) throw new Error('Error fetching progress');
            return resp.json();
        })
        .then(data => {
            if (!data.in_progress && data.done) {
                clearInterval(pollInterval);
                pollInterval = null;
                statusText.textContent = 'Done!';
                progressBar.style.width = '100%';
                progressDetail.textContent = `Elapsed time: ${data.elapsed} seconds.`;

                const url = new URL('/analysis', window.location.href);
                const params = createParams();
                params.forEach((value, key) => url.searchParams.set(key, value));
                window.location.href = url.toString();
            } else {
                const p = data.processed;
                const t = data.total;
                let pct = (t > 0) ? Math.floor((p / t) * 100) : 0;
                progressBar.style.width = pct + '%';
            }
        })
        .catch(err => {
            console.error("Progress check error:", err);
            clearInterval(pollInterval);
        });
    }

    document.querySelectorAll('.subset-cell').forEach(cell => {
        cell.addEventListener('click', function() {
            const preview = this.querySelector('.subset-preview');
            const full = this.querySelector('.subset-full');
            const isExpanded = this.classList.contains('expanded');

            if (isExpanded) {
                preview.style.display = '';
                full.style.display = 'none';
                this.classList.remove('expanded');
            } else {
                preview.style.display = 'none';
                full.style.display = '';
                this.classList.add('expanded');
            }
        });
    });

    if (runBtn) {
        runBtn.addEventListener('click', startAnalysis);
    }
});
</script>

{% endblock content %}

{% block sidebar %}
<h5 class="mt-3">Parameters</h5>

<div class="mb-2">
    <label>Offset from last draw:</label>
    <input id="param-offset-last" type="number" class="form-control form-control-sm"
           value="{{ offset_last|default(0) }}">
</div>

<div class="mb-2">
    <label>n-number subsets of {{ game_config.max_number }}:</label>
    <input id="param-j" type="number" class="form-control form-control-sm" value="{{ j }}">
</div>

<div class="mb-2">
    <label>k-number subsets of n:</label>
    <input id="param-k" type="number" class="form-control form-control-sm" value="{{ k }}">
</div>

<div class="mb-2">
    <label>Sorting option:</label>
    <select id="param-m" class="form-select form-select-sm">
        <option value="avg" {% if m=='avg' %}selected{% endif %}>avg</option>
        <option value="min" {% if m=='min' or not m %}selected{% endif %}>min</option>
    </select>
</div>

<div class="mb-2">
    <label>Number of top-ranked combinations:</label>
    <input id="param-l" type="number" class="form-control form-control-sm" value="{{ l|default(1) }}">
</div>

<div class="mb-2">
    <label>Number of top-ranked combinations w/o overlapping subsets:</label>
    <input id="param-n" type="number" class="form-control form-control-sm" value="{{ n|default(0) }}">
</div>

<button id="run-analysis-btn" class="btn btn-danger btn-sm">Run Analysis</button>
{% endblock sidebar %}

analysis.py
# analysis.py
import ctypes
import os
import sys
import math
import time
import tempfile

import sqlite3
from database import get_db_connection
from config import Config

# Load the compiled C library at import time
# We'll assume the compiled library is named 'libanalysis_engine.so' (Linux),
# or 'analysis_engine.dll' (Windows), or 'libanalysis_engine.dylib' (macOS).
# For simplicity, let's assume Codespaces => Linux => .so
LIB_PATH = os.path.join(
    os.path.dirname(__file__),
    "C_engine", "src", "libanalysis_engine.so"
)

analysis_lib = ctypes.CDLL(LIB_PATH)

# We must define a python equivalent for AnalysisResultItem
class AnalysisResultItem(ctypes.Structure):
    _fields_ = [
        ("combination", ctypes.c_char * 256),
        ("avg_rank", ctypes.c_double),
        ("min_value", ctypes.c_double),
        ("subsets", ctypes.c_char * 512),
        ("draw_offset", ctypes.c_int),
        ("draws_until_common", ctypes.c_int),
        ("analysis_start_draw", ctypes.c_int),
        ("is_chain_result", ctypes.c_int),
    ]

# Provide function signatures
analysis_lib.run_analysis_c.argtypes = [
    ctypes.c_char_p,        # const char* game_type
    ctypes.POINTER(ctypes.POINTER(ctypes.c_int)), # draws
    ctypes.c_int,           # draws_count
    ctypes.c_int,           # j
    ctypes.c_int,           # k
    ctypes.c_char_p,        # m
    ctypes.c_int,           # l
    ctypes.c_int,           # n
    ctypes.c_int,           # last_offset
    ctypes.POINTER(ctypes.c_int) # out_len
]
analysis_lib.run_analysis_c.restype = ctypes.POINTER(AnalysisResultItem)

analysis_lib.free_analysis_results.argtypes = [ctypes.POINTER(AnalysisResultItem)]
analysis_lib.free_analysis_results.restype = None

def run_analysis(game_type='6_42', j=6, k=3, m='min', l=1, n=0,
                 last_offset=0,
                 progress_callback=None,
                 should_stop=lambda: False):
    """
    Re-implemented to call the C library for all the logic.
    Returns (selected_df, top_df, elapsed) to keep the rest of your Flask code working the same.
    We do NOT do partial progress here, so 'progress_callback' is ignored.
    'should_stop' is also not used.
    """
    start_time = time.time()

    # 1) get the draws from the DB
    conn = get_db_connection(game_type)
    c = conn.cursor()
    row_count = c.execute("SELECT COUNT(*) as cnt FROM draws").fetchone()["cnt"]
    if last_offset < 0:
        last_offset = 0
    if last_offset > row_count:
        last_offset = row_count

    draws = c.execute(
        "SELECT number1, number2, number3, number4, number5, number6 FROM draws "
        "ORDER BY sort_order"
    ).fetchall()
    conn.close()

    # Prepare the C array-of-arrays
    draws_count = len(draws)
    # create an array (of pointers to int[6])
    draws_c = (ctypes.POINTER(ctypes.c_int) * draws_count)()
    # each subarray
    for i, row in enumerate(draws):
        row_arr = (ctypes.c_int * 6)()
        for jx in range(6):
            row_arr[jx] = row[jx] if row[jx] is not None else 1
        draws_c[i] = row_arr

    out_len = ctypes.c_int(0)

    results_ptr = analysis_lib.run_analysis_c(
        game_type.encode('utf-8'),    # game_type
        draws_c,                     # draws
        draws_count,                 # draws_count
        j,                           # j
        k,                           # k
        m.encode('utf-8'),           # m
        l,                           # l
        n,                           # n
        last_offset,                 # last_offset
        ctypes.byref(out_len)        # out_len
    )

    res_count = out_len.value
    # Convert them into python lists
    python_results = []
    for i in range(res_count):
        item = results_ptr[i]
        # parse it
        # is_chain_result = 1 => chain analysis row
        # is_chain_result = 0 => normal or top combos
        combination = item.combination.decode('utf-8')
        avg_rank = item.avg_rank
        min_val = item.min_value
        subsets = item.subsets.decode('utf-8')
        draw_offset = item.draw_offset
        draws_until_common = item.draws_until_common
        analysis_start_draw = item.analysis_start_draw
        is_chain_result = item.is_chain_result

        python_results.append({
            "combination": combination,
            "avg_rank": avg_rank,
            "min_value": min_val,
            "subsets": subsets,
            "draw_offset": draw_offset,
            "draws_until_common": draws_until_common,
            "analysis_start_draw": analysis_start_draw,
            "is_chain_result": is_chain_result
        })

    # free memory
    analysis_lib.free_analysis_results(results_ptr)

    elapsed = round(time.time() - start_time)

    if l == -1:
        # chain analysis => top_df is the chain results
        import pandas as pd
        chain_data = []
        for row in python_results:
            chain_data.append({
                'Offset': row['draw_offset'],
                'Combination': row['combination'],
                'Average Rank': row['avg_rank'],
                'MinValue': row['min_value'],
                'Subsets': row['subsets'],
                'Draws Until Common Subset': row['draws_until_common'],
                'Analysis Start Draw': row['analysis_start_draw'],
                'Draw Count': row['draw_offset']
            })
        if len(chain_data) == 0:
            return None, None, 0
        top_df = pd.DataFrame(chain_data)
        selected_df = None
        return selected_df, top_df, elapsed
    else:
        # normal => we have top combos in the front, optional "selected combos" appended
        # your python code was returning top_df and selected_df as two separate DataFrames
        # so let's do the same approach
        import pandas as pd
        # we must figure out how many are top combos and how many are "selected combos"
        # we decided to put them all in one array: top combos first, selected combos second
        # Let's guess the split: if n>0, the second half are "selected combos"
        # we can't know the exact split from the C code, but we do the same logic we used
        # "top-l" combos => first l items (or fewer if fewer combos)
        # "selected combos" => second n items (or fewer if not enough combos)
        # if the total was l + n
        top_data = []
        selected_data = []
        if res_count > 0:
            # figure out how many are "top combos" portion
            top_count = min(l, res_count)
            for i in range(top_count):
                r = python_results[i]
                top_data.append({
                    'Combination': r['combination'],
                    'Average Rank': r['avg_rank'],
                    'MinValue': r['min_value'],
                    'Subsets': r['subsets']
                })
            # the selected portion
            if n > 0 and (res_count > top_count):
                selected_count = min(n, res_count - top_count)
                for i in range(top_count, top_count+selected_count):
                    r = python_results[i]
                    selected_data.append({
                        'Combination': r['combination'],
                        'Average Rank': r['avg_rank'],
                        'MinValue': r['min_value'],
                        'Subsets': r['subsets']
                    })

        top_df = None
        selected_df = None
        if len(top_data) > 0:
            top_df = pd.DataFrame(top_data)
        if len(selected_data) > 0:
            selected_df = pd.DataFrame(selected_data)

        return selected_df, top_df, elapsed

app.py
# app.py

from flask import Flask, render_template, request, make_response, jsonify, redirect, url_for, session
from flask_session import Session
from database import *
# Instead of the old local import from analysis, we keep the same name but now it's the new "analysis.py" that calls C
from analysis import run_analysis
import io
import pandas as pd
import threading
import time
from config import Config

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-here'
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = False
Session(app)

# We keep these global states to mimic your original logic for showing progress
analysis_in_progress = False
analysis_processed = 0
analysis_total = 0
analysis_selected_df = None
analysis_top_df = None
analysis_elapsed = None
analysis_thread = None
analysis_cancel_requested = False

@app.context_processor
def utility_processor():
    return dict(config=Config)

@app.route('/')
def index():
    return render_template('index.html', games=Config.GAMES)

@app.route('/select_game/<game_type>')
def select_game(game_type):
    if game_type not in Config.GAMES:
        return redirect(url_for('index'))
    session['game_type'] = game_type
    game_config = Config.GAMES[game_type]
    return render_template('game_options.html', game_type=game_type, game_config=game_config)

@app.route('/combos', methods=['GET'])
def combos():
    game_type = session.get('game_type', '6_42')
    if not game_type:
        return redirect(url_for('index'))
    limit = request.args.get('limit', 20, type=int)
    offset = request.args.get('offset', 0, type=int)
    total_count = count_draws(game_type)
    return render_template('combos.html',
        limit=limit,
        offset=offset,
        total_count=total_count,
        game_config=Config.GAMES[game_type]
    )

@app.route('/analysis_start', methods=['GET'])
def analysis_start():
    game_type = session.get('game_type', '6_42')
    if not game_type:
        return redirect(url_for('index'))
    game_config = Config.GAMES[game_type]
    j_default = 6

    return render_template(
        'results.html',
        game_config=game_config,
        selected_df=None,
        top_df=None,
        elapsed=None,
        j=j_default,
        k=3,
        m='min',
        l=1,
        n=0,
        offset_last=0
    )

@app.route('/analysis', methods=['GET'])
def analysis_route():
    game_type = session.get('game_type', '6_42')
    j = request.args.get('j', 6, type=int)
    k = request.args.get('k', 3, type=int)
    m = request.args.get('m', 'min')
    l = request.args.get('l', 1, type=int)
    n_val = request.args.get('n', 0, type=int)
    offset_last = request.args.get('offset_last', 0, type=int)
    global analysis_selected_df, analysis_top_df, analysis_elapsed

    return render_template(
        'results.html',
        j=j, k=k, m=m, l=l, n=n_val,
        offset_last=offset_last,
        selected_df=analysis_selected_df,
        top_df=analysis_top_df,
        elapsed=analysis_elapsed,
        game_config=Config.GAMES[game_type]
    )

@app.route('/analysis_run', methods=['POST'])
def analysis_run():
    global analysis_in_progress, analysis_processed, analysis_total
    global analysis_selected_df, analysis_top_df, analysis_elapsed
    global analysis_thread, analysis_cancel_requested

    game_type = session.get('game_type', '6_42')
    j = request.form.get('j', type=int, default=6)
    k = request.form.get('k', type=int, default=3)
    m = request.form.get('m', type=str, default='min')
    l = request.form.get('l', type=int, default=1)
    n_val = request.form.get('n', type=int, default=0)
    offset_val = request.form.get('offset_last', type=int, default=0)

    # Cancel any ongoing analysis
    if analysis_in_progress:
        analysis_cancel_requested = True
        if analysis_thread and analysis_thread.is_alive():
            analysis_thread.join()
        analysis_cancel_requested = False
        analysis_in_progress = False

    analysis_in_progress = True
    analysis_processed = 0
    analysis_total = 0
    analysis_selected_df = None
    analysis_top_df = None
    analysis_elapsed = None

    def worker():
        global analysis_in_progress, analysis_selected_df, analysis_top_df, analysis_elapsed
        sel_df, top_df, elapsed = run_analysis(
            game_type=game_type,
            j=j, k=k, m=m, l=l, n=n_val,
            last_offset=offset_val
        )
        analysis_selected_df = sel_df
        analysis_top_df = top_df
        analysis_elapsed = elapsed
        analysis_in_progress = False

    analysis_thread = threading.Thread(target=worker)
    analysis_thread.start()
    return "OK"

@app.route('/analysis_progress', methods=['GET'])
def analysis_progress():
    # We'll skip partial progress updates
    global analysis_in_progress, analysis_processed, analysis_total, analysis_elapsed
    resp = {
        'in_progress': analysis_in_progress,
        'processed': analysis_processed,
        'total': analysis_total,
        'done': (not analysis_in_progress) and (analysis_elapsed is not None),
        'elapsed': analysis_elapsed
    }
    return jsonify(resp)

@app.route('/download_selected_csv', methods=['GET'])
def download_selected_csv():
    global analysis_selected_df
    if analysis_selected_df is None:
        return "No analysis run yet", 400
    output = io.StringIO()
    analysis_selected_df.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=selected_combinations.csv"
    response.headers["Content-type"] = "text/csv"
    return response

@app.route('/download_top_csv', methods=['GET'])
def download_top_csv():
    global analysis_top_df
    if analysis_top_df is None:
        return "No analysis run yet", 400
    output = io.StringIO()
    analysis_top_df.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=top_combinations.csv"
    response.headers["Content-type"] = "text/csv"
    return response

if __name__ == '__main__':
    port = int(os.environ.get("PORT", 10000))
    app.run(host='0.0.0.0', port=port, debug=False)

database.py
# database.py

import sqlite3
import pandas as pd
from config import Config

def get_db_connection(game_type='6_42'):
    db_path = Config.GAMES[game_type]['db_name']
    conn = sqlite3.connect(db_path, timeout=5)
    conn.row_factory = sqlite3.Row
    return conn

def renumber_all(game_type='6_42'):
    conn = get_db_connection(game_type)
    c = conn.cursor()
    rows = c.execute("SELECT id FROM draws ORDER BY sort_order").fetchall()
    for i, row in enumerate(rows, start=1):
        draw_number = f"{i:04d}"
        c.execute("UPDATE draws SET sort_order=?, draw_number=? WHERE id=?",
                  (i, draw_number, row['id']))
    conn.commit()
    conn.close()

def get_draws(game_type='6_42', limit=100, offset=0):
    conn = get_db_connection(game_type)
    draws = conn.execute(
        "SELECT * FROM draws ORDER BY sort_order LIMIT ? OFFSET ?",
        (limit, offset)
    ).fetchall()
    conn.close()
    return draws

def count_draws(game_type='6_42'):
    conn = get_db_connection(game_type)
    count = conn.execute("SELECT COUNT(*) as cnt FROM draws").fetchone()["cnt"]
    conn.close()
    return count

def insert_draw(numbers, game_type='6_42', after_id=None):
    numbers = clamp_numbers(numbers, game_type)
    conn = get_db_connection(game_type)
    c = conn.cursor()

    if after_id:
        row = c.execute("SELECT sort_order FROM draws WHERE id=?", (after_id,)).fetchone()
        if row:
            after_sort = row["sort_order"]
            c.execute("UPDATE draws SET sort_order = sort_order + 1 WHERE sort_order > ?", (after_sort,))
            new_sort_order = after_sort + 1
        else:
            max_so = c.execute("SELECT MAX(sort_order) FROM draws").fetchone()[0]
            new_sort_order = (max_so or 0) + 1
    else:
        max_so = c.execute("SELECT MAX(sort_order) FROM draws").fetchone()[0]
        new_sort_order = (max_so or 0) + 1

    draw_number = "temp"
    c.execute('''
        INSERT INTO draws (draw_number, number1, number2, number3, number4, number5, number6, sort_order)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (draw_number, *numbers, new_sort_order))
    conn.commit()
    conn.close()

    renumber_all(game_type)

def delete_draw(draw_id, game_type='6_42'):
    conn = get_db_connection(game_type)
    conn.execute("DELETE FROM draws WHERE id = ?", (draw_id,))
    conn.commit()
    conn.close()
    renumber_all(game_type)

def delete_draws(ids, game_type='6_42'):
    conn = get_db_connection(game_type)
    q_marks = ",".join("?" for _ in ids)
    sql = f"DELETE FROM draws WHERE id IN ({q_marks})"
    conn.execute(sql, ids)
    conn.commit()
    conn.close()
    renumber_all(game_type)

def update_draw(draw_id, numbers, game_type='6_42'):
    numbers = clamp_numbers(numbers, game_type)
    conn = get_db_connection(game_type)
    conn.execute('''
        UPDATE draws
        SET number1=?, number2=?, number3=?, number4=?, number5=?, number6=?
        WHERE id=?
    ''', (*numbers, draw_id))
    conn.commit()
    conn.close()

def get_all_draws(game_type='6_42'):
    conn = get_db_connection(game_type)
    rows = conn.execute("SELECT * FROM draws ORDER BY sort_order").fetchall()
    conn.close()
    return rows

def swap_sort_order(id1, id2, game_type='6_42'):
    conn = get_db_connection(game_type)
    c = conn.cursor()
    so1 = c.execute("SELECT sort_order FROM draws WHERE id=?", (id1,)).fetchone()["sort_order"]
    so2 = c.execute("SELECT sort_order FROM draws WHERE id=?", (id2,)).fetchone()["sort_order"]
    c.execute("UPDATE draws SET sort_order=? WHERE id=?", (so2, id1))
    c.execute("UPDATE draws SET sort_order=? WHERE id=?", (so1, id2))
    conn.commit()
    conn.close()
    renumber_all(game_type)

def clamp_numbers(nums, game_type='6_42'):
    max_number = Config.GAMES[game_type]['max_number']
    cleaned = []
    for n in nums:
        if n is None:
            cleaned.append(None)
        else:
            if n < 1:
                n = 1
            if n > max_number:
                n = max_number
            cleaned.append(n)
    return cleaned

init_database.py
# init_database.py
import pandas as pd
import sqlite3
import sys
from config import Config

def init_db(game_type):
    game_config = Config.GAMES[game_type]
    max_number = game_config['max_number']
    conn = sqlite3.connect(game_config['db_name'])
    c = conn.cursor()

    c.execute('DROP TABLE IF EXISTS draws')

    max_number = game_config['max_number']
    c.execute(f'''
        CREATE TABLE draws (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            draw_number TEXT,
            number1 INTEGER CHECK (number1 IS NULL OR (number1 >= 1 AND number1 <= {max_number})),
            number2 INTEGER CHECK (number2 IS NULL OR (number2 >= 1 AND number2 <= {max_number})),
            number3 INTEGER CHECK (number3 IS NULL OR (number3 >= 1 AND number3 <= {max_number})),
            number4 INTEGER CHECK (number4 IS NULL OR (number4 >= 1 AND number4 <= {max_number})),
            number5 INTEGER CHECK (number5 IS NULL OR (number5 >= 1 AND number5 <= {max_number})),
            number6 INTEGER CHECK (number6 IS NULL OR (number6 >= 1 AND number6 <= {max_number})),
            sort_order INTEGER
        )
    ''')

    conn.commit()
    return conn

def load_csv_to_db(game_type):
    try:
        game_config = Config.GAMES[game_type]
        df = pd.read_csv(game_config['csv_file'], header=None)
        df = df.iloc[1:].reset_index(drop=True)
        df['draw_number'] = df.index.map(lambda x: f'{x+1:04d}')

        conn = init_db(game_type)
        cursor = conn.cursor()

        for index, row in df.iterrows():
            numbers = sorted(row.iloc[:6].astype(int).tolist())
            draw_number = row['draw_number']
            cursor.execute('''
                INSERT INTO draws (draw_number, number1, number2, number3, number4, number5, number6)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (draw_number, *numbers))

        cursor.execute("UPDATE draws SET sort_order = id")
        conn.commit()
        conn.close()

        print(f"Successfully loaded {len(df)} draws into {game_config['db_name']}")
        return True
    except Exception as e:
        print(f"Error: {str(e)}")
        return False

if __name__ == "__main__":
    for game_type in Config.GAMES:
        print(f"\nInitializing database for {Config.GAMES[game_type]['name']}...")
        success = load_csv_to_db(game_type)
        if not success:
            sys.exit(1)

config.py
# config.py (new file)
class Config:
    GAMES = {
        '6_42': {
            'name': 'Toto 6/42',
            'max_number': 42,
            'db_name': 'toto_6_42_draws.db',
            'csv_file': 'Toto_6_42_with_first_row.csv'
        },
        '6_49': {
            'name': 'Toto 6/49',
            'max_number': 49,
            'db_name': 'toto_6_49_draws.db',
            'csv_file': 'Toto_6_49_with_first_row.csv'
        }
    }

requirements.txt
gunicorn==21.2.0
Flask==2.2.2
pandas==1.5.3
statistics;python_version<"3.10"
seaborn==0.12.0
tqdm==4.66.1
Flask-Session==0.5.0
numpy==1.23.2
itsdangerous==2.0.0
Werkzeug==2.2.2
click==8.0.0
Jinja2==3.0.0
MarkupSafe==2.1.1

C_engine/src/analysis_engine.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>

#include "analysis_engine.h"

/*
 * This version replicates your Python logic exactly (for normal and chain analysis),
 * but also:
 *   - Manually ensures null termination in strncpy calls (no truncation warning).
 *   - Adds simple sanity checks for j and out_len to silence large allocation warnings.
 * Thus, it returns the same results as your second screenshot while avoiding warnings.
 */

#define MAX_COMBO_STR 255   // combination[] field length
#define MAX_SUBSETS_STR 511 // subsets[] field length

// If you want a different upper bound, adjust these:
#define MAX_ALLOWED_J 200      // combos bigger than 200 are unrealistic for TOTO
#define MAX_ALLOWED_OUT_LEN 1000000  // 1 million, just a safe upper bound

/*
 * Compute nCr (combinations).
 */
static long long comb_ll(int n, int r) {
    if (r > n) return 0;
    if (r == 0 || r == n) return 1;
    long long result = 1;
    for (int i = 1; i <= r; i++) {
        result = result * (n - r + i) / i;
    }
    return result;
}

/*
 * Move from one ascending combination to the next.
 * Returns 1 if advanced, 0 if done.
 */
static int next_combination(int *comb, int k, int n) {
    int rpos = k - 1;
    while (rpos >= 0 && comb[rpos] == (n - k + rpos + 1)) {
        rpos--;
    }
    if (rpos < 0) {
        return 0;
    }
    comb[rpos]++;
    for (int i = rpos + 1; i < k; i++) {
        comb[i] = comb[i - 1] + 1;
    }
    return 1;
}

/*
 * SubsetOccDict for storing k-subset weights.
 */
typedef struct {
    long long *subset_weights;
    int max_subsets;
    int subset_size;
    int max_number;
} SubsetOccDict;

/*
 * Create / free.
 */
static SubsetOccDict* create_subset_occdict(int max_number, int k) {
    SubsetOccDict* d = (SubsetOccDict*)calloc(1, sizeof(SubsetOccDict));
    d->max_number = max_number;
    d->subset_size = k;
    d->max_subsets = (int)comb_ll(max_number, k);
    d->subset_weights = (long long*)calloc(d->max_subsets, sizeof(long long));
    return d;
}

static void free_subset_occdict(SubsetOccDict* d) {
    if (!d) return;
    free(d->subset_weights);
    free(d);
}

/*
 * Map a sorted subset[] of size k to an index in [0..comb(max_number,k)-1].
 */
static int subset_to_index(const int* subset, int k, int max_number) {
    long long rank = 0;
    int start = 1;
    for (int i = 0; i < k; i++) {
        int x = subset[i];
        for (int val = start; val < x; val++) {
            rank += comb_ll(max_number - val, k - i - 1);
        }
        start = x + 1;
    }
    return (int)rank;
}

/*
 * Add 'weight' to each k-subset of 'numbers'.
 * 'numbers' is sorted, up to 6 elements for TOTO draws.
 */
static void update_subset_occdict(SubsetOccDict* d, const int* numbers, int count, long long weight) {
    if (!d || d->subset_size > count) return;

    int k = d->subset_size;
    int comb[20];
    for (int i = 0; i < k; i++) {
        comb[i] = i;
    }
    while (1) {
        int temp[20];
        for (int i = 0; i < k; i++) {
            temp[i] = numbers[comb[i]];
        }
        int idx = subset_to_index(temp, k, d->max_number);
        if (idx >= 0 && idx < d->max_subsets) {
            d->subset_weights[idx] += weight;
        }

        int rpos = k - 1;
        while (rpos >= 0 && comb[rpos] == (rpos + (count - k))) {
            rpos--;
        }
        if (rpos < 0) break;
        comb[rpos]++;
        for (int j = rpos + 1; j < k; j++) {
            comb[j] = comb[j - 1] + 1;
        }
    }
}

/*
 * Convert an integer combo to "1,2,3,4,5,6".
 */
static void combo_to_string(const int *combo, int j, char* out_str) {
    out_str[0] = '\0';
    char tmp[32];
    for(int i = 0; i < j; i++){
        snprintf(tmp, sizeof(tmp), "%d", combo[i]);
        strcat(out_str, tmp);
        if(i < j-1) strcat(out_str, ",");
    }
}

/*
 * Builds something like "[((2,9,14), 346), ((2,9,21), 281), ...]" for the subsets.
 */
static void build_subsets_string(
    int* combo,
    int j,
    int k,
    SubsetOccDict* occ,
    int max_number,
    char* out_buf
) {
    char big[16384];
    big[0] = '\0';
    strcat(big, "[");

    int ccomb[20];
    for(int i=0; i<k; i++){
        ccomb[i] = i;
    }

    int first_entry = 1;
    while (1) {
        int temp[20];
        for(int x=0; x<k; x++){
            temp[x] = combo[ccomb[x]];
        }
        int idx = subset_to_index(temp, k, max_number);
        long long w = 0;
        if(idx >= 0 && idx < occ->max_subsets){
            w = occ->subset_weights[idx];
        }

        char subset_str[128];
        subset_str[0] = '\0';
        strcat(subset_str, "(");
        for(int z=0; z<k; z++){
            char numbuf[32];
            snprintf(numbuf, sizeof(numbuf), "%d", temp[z]);
            strcat(subset_str, numbuf);
            if(z < k-1) strcat(subset_str, ", ");
        }
        strcat(subset_str, ")");

        if(!first_entry) {
            strcat(big, ", ");
        } else {
            first_entry = 0;
        }

        char entry[256];
        snprintf(entry, sizeof(entry), "(%s, %lld)", subset_str, w);
        strcat(big, entry);

        int rpos = k - 1;
        while(rpos >= 0 && ccomb[rpos] == (rpos + (j - k))) {
            rpos--;
        }
        if(rpos < 0) break;
        ccomb[rpos]++;
        for(int xx = rpos+1; xx < k; xx++){
            ccomb[xx] = ccomb[xx-1] + 1;
        }
    }

    strcat(big, "]");

    // Truncate to 511 chars, ensure null termination
    strncpy(out_buf, big, MAX_SUBSETS_STR);
    out_buf[MAX_SUBSETS_STR] = '\0';
}

/*
 * The main analysis function. Exactly replicates your original Python weighting logic:
 * Chain (l == -1) or Normal (top-l).
 */
AnalysisResultItem* run_analysis_c(
    const char* game_type,
    int** draws,
    int draws_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int last_offset,
    int* out_len
) {
    // Quick checks to silence large-allocation warnings
    if (j > MAX_ALLOWED_J) {
        fprintf(stderr, "Error: j=%d exceeds safety limit %d.\n", j, MAX_ALLOWED_J);
        *out_len = 0;
        return NULL;
    }

    int max_number = 42;
    if (strstr(game_type, "6_49")) {
        max_number = 49;
    }

    *out_len = 0;
    AnalysisResultItem* results = NULL;

    // CHAIN analysis if l == -1
    if (l == -1) {
        int capacity = 1000;
        results = (AnalysisResultItem*)calloc(capacity, sizeof(AnalysisResultItem));
        int total_draws = draws_count;
        int current_offset = last_offset;

        // Sort ascending
        for(int i=0; i<draws_count; i++){
            for(int a=0; a<5; a++){
                for(int b=a+1; b<6; b++){
                    if(draws[i][a] > draws[i][b]){
                        int tmp = draws[i][a];
                        draws[i][a] = draws[i][b];
                        draws[i][b] = tmp;
                    }
                }
            }
        }

        while (current_offset >= 0 && current_offset < total_draws) {
            int use_count = total_draws - current_offset;
            if(use_count < 1) break;

            SubsetOccDict* occ = create_subset_occdict(max_number, k);
            // Weighted approach: for idx in reversed(range(use_count))
            for(int idx = use_count - 1; idx >= 0; idx--){
                long long weight = (use_count - 1) - idx;
                update_subset_occdict(occ, draws[idx], 6, weight);
            }

            // Find best combo
            int* comb_arr = (int*)malloc(sizeof(int)*j);
            for(int i=0; i<j; i++){
                comb_arr[i] = i+1;
            }

            double best_val = -1e9;
            double best_avg = 0.0;
            double best_minv = 0.0;
            int best_combo[64];
            char best_subsets[512] = {0};

            do {
                long long sum_occ = 0;
                long long min_occ = LLONG_MAX;

                int ccomb[20];
                for(int i=0; i<k; i++){
                    ccomb[i] = i;
                }
                while(1) {
                    int temp[20];
                    for(int x=0; x<k; x++){
                        temp[x] = comb_arr[ccomb[x]];
                    }
                    int idx_s = subset_to_index(temp, k, max_number);
                    long long w = 0;
                    if(idx_s>=0 && idx_s<occ->max_subsets){
                        w = occ->subset_weights[idx_s];
                    }
                    sum_occ += w;
                    if(w < min_occ) min_occ = w;

                    int rpos = k-1;
                    while(rpos>=0 && ccomb[rpos] == (rpos + (j - k))) rpos--;
                    if(rpos<0) break;
                    ccomb[rpos]++;
                    for(int xx=rpos+1; xx<k; xx++){
                        ccomb[xx] = ccomb[xx-1]+1;
                    }
                }

                double avg_occ = (double)sum_occ / (double)comb_ll(j, k);
                double sort_field = 0.0;
                if(strcmp(m, "avg") == 0) {
                    sort_field = avg_occ;
                } else {
                    sort_field = (double)min_occ;
                }

                if(sort_field > best_val) {
                    best_val = sort_field;
                    best_avg = avg_occ;
                    best_minv = (double)min_occ;
                    memcpy(best_combo, comb_arr, j*sizeof(int));
                    build_subsets_string(best_combo, j, k, occ, max_number, best_subsets);
                }
            } while(next_combination(comb_arr, j, max_number));

            free(comb_arr);
            free_subset_occdict(occ);

            // draws_until_match
            int draws_until_match = 0;
            int found = 0;
            for(int dd = (total_draws - use_count); dd < total_draws; dd++){
                draws_until_match++;
                int row[6];
                memcpy(row, draws[dd], sizeof(int)*6);

                int match_found = 0;
                int ccomb[20];
                for(int i=0; i<k; i++){
                    ccomb[i] = i;
                }
                while(!match_found) {
                    int temp_bc[20];
                    for(int x=0; x<k; x++){
                        temp_bc[x] = best_combo[ccomb[x]];
                    }
                    int rcomb[20];
                    for(int i=0; i<k; i++){
                        rcomb[i] = i;
                    }
                    while(1) {
                        int temp_row[20];
                        for(int x=0; x<k; x++){
                            temp_row[x] = row[rcomb[x]];
                        }
                        int eq=1;
                        for(int z=0; z<k; z++){
                            if(temp_bc[z] != temp_row[z]) {
                                eq = 0;
                                break;
                            }
                        }
                        if(eq) {
                            match_found = 1;
                            break;
                        }
                        int rrpos = k-1;
                        while(rrpos>=0 && rcomb[rrpos] == (rrpos + (6 - k))) rrpos--;
                        if(rrpos<0) break;
                        rcomb[rrpos]++;
                        for(int xx=rrpos+1; xx<k; xx++){
                            rcomb[xx] = rcomb[xx-1]+1;
                        }
                    }
                    int rpos = k-1;
                    while(rpos>=0 && ccomb[rpos] == (rpos + (j - k))) rpos--;
                    if(rpos<0) break;
                    ccomb[rpos]++;
                    for(int xx=rpos+1; xx<k; xx++){
                        ccomb[xx] = ccomb[xx-1]+1;
                    }
                }

                if(match_found) {
                    found = 1;
                    break;
                }
            }
            if(!found) {
                draws_until_match = use_count;
            }

            // Add chain result
            if(*out_len >= capacity) {
                capacity *= 2;
                results = (AnalysisResultItem*)realloc(results, sizeof(AnalysisResultItem)*capacity);
            }
            AnalysisResultItem* outR = &results[*out_len];
            memset(outR, 0, sizeof(AnalysisResultItem));
            outR->is_chain_result = 1;
            outR->draw_offset = current_offset;
            outR->analysis_start_draw = total_draws - current_offset;
            outR->draws_until_common = draws_until_match - 1;

            char combo_str[512] = {0};
            combo_to_string(best_combo, j, combo_str);
            // Copy safely
            if(strlen(combo_str) >= MAX_COMBO_STR) {
                strncpy(outR->combination, combo_str, MAX_COMBO_STR - 1);
                outR->combination[MAX_COMBO_STR - 1] = '\0';
            } else {
                strcpy(outR->combination, combo_str);
            }

            outR->avg_rank = best_avg;
            outR->min_value = best_minv;

            if(strlen(best_subsets) >= MAX_SUBSETS_STR) {
                strncpy(outR->subsets, best_subsets, MAX_SUBSETS_STR - 1);
                outR->subsets[MAX_SUBSETS_STR - 1] = '\0';
            } else {
                strcpy(outR->subsets, best_subsets);
            }

            (*out_len)++;

            if(!found) {
                break;
            } else {
                current_offset = current_offset - draws_until_match;
            }
        }

        // Final check for out_len
        if (*out_len > MAX_ALLOWED_OUT_LEN) {
            fprintf(stderr, "Error: out_len=%d exceeds safety limit %d.\n", *out_len, MAX_ALLOWED_OUT_LEN);
            free(results);
            results = NULL;
            *out_len = 0;
        }
        return results;
    }
    // NORMAL analysis
    else {
        int use_count = draws_count - last_offset;
        if(use_count < 1) {
            return NULL;
        }
        // sort ascending
        for(int i=0; i<draws_count; i++){
            for(int a=0; a<5; a++){
                for(int b=a+1; b<6; b++){
                    if(draws[i][a] > draws[i][b]){
                        int tmp = draws[i][a];
                        draws[i][a] = draws[i][b];
                        draws[i][b] = tmp;
                    }
                }
            }
        }

        SubsetOccDict* occ = create_subset_occdict(max_number, k);

        // EXACT Python weighting: reversed
        for(int idx = use_count - 1; idx >= 0; idx--){
            long long weight = (use_count - 1) - idx;
            update_subset_occdict(occ, draws[idx], 6, weight);
        }

        long long total_combos = comb_ll(max_number, j);
        if(total_combos <= 0) {
            free_subset_occdict(occ);
            return NULL;
        }

        // We'll store up to l combos
        typedef struct {
            int combo[64];
            int combo_len;
            double avg_occurrence;
            double min_occurrence;
            char subsets[512];
        } ComboStats;

        ComboStats* best_array = (ComboStats*)calloc(l, sizeof(ComboStats));
        int filled = 0;

        int* comb_arr = (int*)malloc(sizeof(int)*j);
        for(int i=0; i<j; i++){
            comb_arr[i] = i+1;
        }

        do {
            long long sum_occ = 0;
            long long min_occ = LLONG_MAX;

            // Build subsets
            char big_subsets[512] = {0};
            char big_temp[16384];
            big_temp[0] = '\0';
            strcat(big_temp, "[");

            int ccomb[20];
            for(int i=0; i<k; i++){
                ccomb[i] = i;
            }
            int first_sub = 1;

            while(1) {
                int temp[20];
                for(int x=0; x<k; x++){
                    temp[x] = comb_arr[ccomb[x]];
                }
                int idx_s = subset_to_index(temp, k, max_number);
                long long w = 0;
                if(idx_s>=0 && idx_s<occ->max_subsets){
                    w = occ->subset_weights[idx_s];
                }
                sum_occ += w;
                if(w < min_occ) min_occ = w;

                // add to big_temp
                char subset_str[128];
                subset_str[0] = '\0';
                strcat(subset_str, "(");
                for(int z=0; z<k; z++){
                    char numbuf[32];
                    snprintf(numbuf, sizeof(numbuf), "%d", temp[z]);
                    strcat(subset_str, numbuf);
                    if(z<k-1) strcat(subset_str, ", ");
                }
                strcat(subset_str, ")");

                if(!first_sub) {
                    strcat(big_temp, ", ");
                } else {
                    first_sub = 0;
                }
                char entry[256];
                snprintf(entry, sizeof(entry), "(%s, %lld)", subset_str, w);
                strcat(big_temp, entry);

                int rpos = k - 1;
                while(rpos>=0 && ccomb[rpos] == (rpos + (j - k))) rpos--;
                if(rpos<0) break;
                ccomb[rpos]++;
                for(int xx=rpos+1; xx<k; xx++){
                    ccomb[xx] = ccomb[xx-1]+1;
                }
            }
            strcat(big_temp, "]");
            strncpy(big_subsets, big_temp, 511);
            big_subsets[511] = '\0';

            double avg_occ = (double)sum_occ / (double)comb_ll(j, k);
            double sort_field = 0.0;
            if(strcmp(m,"avg") == 0) {
                sort_field = avg_occ;
            } else {
                sort_field = (double)min_occ;
            }

            if(filled < l) {
                ComboStats* slot = &best_array[filled];
                memcpy(slot->combo, comb_arr, j*sizeof(int));
                slot->combo_len = j;
                slot->avg_occurrence = avg_occ;
                slot->min_occurrence = min_occ;
                strncpy(slot->subsets, big_subsets, 511);
                slot->subsets[511] = '\0';
                filled++;
            } else {
                // find smallest
                double min_val = 1e18;
                int min_idx = -1;
                for(int i=0; i<l; i++){
                    double sfield = (strcmp(m,"avg")==0)
                                    ? best_array[i].avg_occurrence
                                    : best_array[i].min_occurrence;
                    if(sfield < min_val) {
                        min_val = sfield;
                        min_idx = i;
                    }
                }
                if(sort_field > min_val && min_idx>=0) {
                    ComboStats* slot = &best_array[min_idx];
                    memcpy(slot->combo, comb_arr, j*sizeof(int));
                    slot->combo_len = j;
                    slot->avg_occurrence = avg_occ;
                    slot->min_occurrence = min_occ;
                    strncpy(slot->subsets, big_subsets, 511);
                    slot->subsets[511] = '\0';
                }
            }

        } while(next_combination(comb_arr, j, max_number));

        free(comb_arr);
        free_subset_occdict(occ);

        // Sort best_array descending
        for(int i=0; i<filled; i++){
            for(int jx=i+1; jx<filled; jx++){
                double i_field = (strcmp(m,"avg")==0)
                                 ? best_array[i].avg_occurrence
                                 : best_array[i].min_occurrence;
                double j_field = (strcmp(m,"avg")==0)
                                 ? best_array[jx].avg_occurrence
                                 : best_array[jx].min_occurrence;
                if(j_field > i_field) {
                    ComboStats tmp = best_array[i];
                    best_array[i] = best_array[jx];
                    best_array[jx] = tmp;
                }
            }
        }

        // We produce up to l combos plus n combos
        int final_len = filled + ((n > 0) ? filled : 0);

        if (final_len > MAX_ALLOWED_OUT_LEN) {
            fprintf(stderr, "Error: final_len=%d exceeds safety limit %d.\n", final_len, MAX_ALLOWED_OUT_LEN);
            free(best_array);
            return NULL;
        }

        results = (AnalysisResultItem*)calloc(final_len, sizeof(AnalysisResultItem));
        *out_len = final_len;

        // top combos
        for(int i=0; i<filled; i++){
            AnalysisResultItem* outR = &results[i];
            outR->is_chain_result = 0;

            // Build combo string
            char combo_str[512] = {0};
            combo_to_string(best_array[i].combo, best_array[i].combo_len, combo_str);
            if(strlen(combo_str) >= MAX_COMBO_STR) {
                strncpy(outR->combination, combo_str, MAX_COMBO_STR - 1);
                outR->combination[MAX_COMBO_STR - 1] = '\0';
            } else {
                strcpy(outR->combination, combo_str);
            }

            outR->avg_rank = best_array[i].avg_occurrence;
            outR->min_value = best_array[i].min_occurrence;

            if(strlen(best_array[i].subsets) >= MAX_SUBSETS_STR) {
                strncpy(outR->subsets, best_array[i].subsets, MAX_SUBSETS_STR - 1);
                outR->subsets[MAX_SUBSETS_STR - 1] = '\0';
            } else {
                strcpy(outR->subsets, best_array[i].subsets);
            }
        }

        // n "selected combos" (simple approach)
        if(n > 0) {
            int sel_count = 0;
            for(int i=0; i<filled; i++){
                if(sel_count >= n) break;
                int idx_out = filled + sel_count;
                AnalysisResultItem* outR = &results[idx_out];
                outR->is_chain_result = 0;

                char combo_str[512] = {0};
                combo_to_string(best_array[i].combo, best_array[i].combo_len, combo_str);
                if(strlen(combo_str) >= MAX_COMBO_STR) {
                    strncpy(outR->combination, combo_str, MAX_COMBO_STR - 1);
                    outR->combination[MAX_COMBO_STR - 1] = '\0';
                } else {
                    strcpy(outR->combination, combo_str);
                }

                outR->avg_rank = best_array[i].avg_occurrence;
                outR->min_value = best_array[i].min_occurrence;

                if(strlen(best_array[i].subsets) >= MAX_SUBSETS_STR) {
                    strncpy(outR->subsets, best_array[i].subsets, MAX_SUBSETS_STR - 1);
                    outR->subsets[MAX_SUBSETS_STR - 1] = '\0';
                } else {
                    strcpy(outR->subsets, best_array[i].subsets);
                }

                sel_count++;
            }
        }

        free(best_array);
        return results;
    }
}

/*
 * Free the array returned by run_analysis_c().
 */
void free_analysis_results(AnalysisResultItem* results) {
    if (results) free(results);
}

C_engine/src/analysis_engine.h
#ifndef ANALYSIS_ENGINE_H
#define ANALYSIS_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

/*
 * This struct represents a single result item from the "top" or "chain" analysis.
 * We'll return an array of these from the C engine.
 */
typedef struct {
    // For single or top analysis:
    // Combination in ascending order as a string, e.g. "1,2,3,4,5,6"
    char combination[256];

    // The average rank across subsets
    double avg_rank;

    // The min value across subsets
    double min_value;

    // Subsets (for demonstration, just a truncated string)
    char subsets[512];

    // For chain analysis only:
    // If l = -1, we store these extra fields
    int draw_offset;
    int draws_until_common;
    int analysis_start_draw;
    int is_chain_result; // 1 if chain result, 0 if normal
} AnalysisResultItem;

/*
 * Main function to run analysis.
 *   game_type: e.g. "6_42"
 *   draws: array of 6-element arrays containing the draws. draws[i][0..5]
 *   draws_count: how many draws we have
 *   j, k, m, l, n, last_offset: same meaning as in your Python code
 *
 * returns: a pointer to an array of AnalysisResultItem. 'out_len' is set
 *          to the number of results. The caller (Python) will free it
 *          with free_analysis_results().
 */
AnalysisResultItem* run_analysis_c(
    const char* game_type,
    int** draws,
    int draws_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int last_offset,
    int* out_len
);

/*
 * Frees the array returned by run_analysis_c().
 */
void free_analysis_results(AnalysisResultItem* results);

#ifdef __cplusplus
}
#endif

#endif

</current_code>

<goals>

</goals>

<constraints>

</constraints>


