<current_code>

Procfile
web: gunicorn app:app

static/css/custom.css
/* static/css/custom.css */
table#combos-table tr.selected {
    background-color: #ffb347 !important;
    color: #000 !important;
    font-weight: bold;
}

static/js/main.js
// static/js/main.js
// This file can remain empty now since all Handsontable logic moved into combos.html

templates/game_options.html
{% extends "layout_no_sidebar.html" %}

{% block content %}
<div class="text-center">
    <h2>{{ game_config.name }} Options</h2>
    <div class="row mt-4 justify-content-center">
        <div class="col-md-5">
            <div class="card mb-4">
                <div class="card-header">
                    <h5>View/Edit Combinations</h5>
                </div>
                <div class="card-body">
                    <p>Browse, edit, and manage existing combinations for {{ game_config.name }}.</p>
                    <a href="{{ url_for('combos') }}" class="btn btn-primary">View Combos</a>
                </div>
            </div>
        </div>
        <div class="col-md-5">
            <div class="card mb-4">
                <div class="card-header">
                    <h5>Run Analysis</h5>
                </div>
                <div class="card-body">
                    <p>Perform advanced analysis on combinations for {{ game_config.name }}.</p>
                    <a href="{{ url_for('analysis_start') }}" class="btn btn-success">Start Analysis</a>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

templates/combos.html
{% extends "layout.html" %}

{% block sidebar %}
<h5 class="mt-3">Combos Navigation</h5>
<div class="mb-2 d-flex justify-content-between">
    <button onclick="goTop()" class="btn btn-secondary">Top</button>
    <button class="btn btn-secondary" onclick="pageUp()">Page Up</button>
</div>
<div class="mb-2 d-flex justify-content-between">
    <button class="btn btn-secondary" onclick="bottom()">Bottom</button>
    <button class="btn btn-secondary" onclick="pageDown()">Page Down</button>
</div>

<form method="get" action="{{ url_for('combos') }}" class="mb-2">
    <div class="mb-2">
        <label>Page Size:</label>
        <input type="number" name="limit" value="{{ limit|default(20) }}" class="form-control">
    </div>
    <div class="mb-2">
        <label>Current Offset:</label>
        <input type="number" name="offset" value="{{ offset }}" class="form-control">
    </div>
    <button type="submit" class="btn btn-primary">Go</button>
</form>

<hr>

<a href="{{ url_for('download_all_combos') }}" class="btn btn-info mb-2">Download All as CSV</a>
{% endblock sidebar %}

{% block content %}
<h2>Existing Combos</h2>
<p>Total Count: <span id="total-count">{{ total_count }}</span></p>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@11.1.0/dist/handsontable.full.min.css">
<script src="https://cdn.jsdelivr.net/npm/handsontable@11.1.0/dist/handsontable.full.min.js"></script>

<div id="hot" style="width:100%; height:600px; overflow:auto;"></div>

<script>
let total_count = {{ total_count }};
let limit = parseInt('{{ limit|default(20) }}', 10);
let offset = parseInt('{{ offset }}', 10);

function updateTotalCount(delta) {
    total_count += delta;
    document.getElementById('total-count').textContent = total_count;
}

function navigate(o) {
    window.location.href = '{{ url_for("combos") }}?limit=' + limit + '&offset=' + o;
}
function goTop(){
    navigate(0);
}
function pageUp() {
    let newOffset = offset - limit;
    if (newOffset < 0) newOffset = 0;
    navigate(newOffset);
}
function bottom() {
    let newOffset = total_count - limit;
    if (newOffset < 0) newOffset = 0;
    navigate(newOffset);
}
function pageDown() {
    let newOffset = offset + limit;
    navigate(newOffset);
}

const container = document.getElementById('hot');
let hot;
let loading = false;

function loadData() {
  loading = true;
  fetch('/combos_data?limit=' + limit + '&offset=' + offset)
    .then(response => response.json())
    .then(data => {
      hot.loadData(data);
      loading = false;
    });
}

hot = new Handsontable(container, {
  data: [],
  colHeaders: ["Draw", "#1", "#2", "#3", "#4", "#5", "#6", "ID"],
  columns: [
    { data: 0, readOnly: true },
    { data: 1, type: 'numeric' },
    { data: 2, type: 'numeric' },
    { data: 3, type: 'numeric' },
    { data: 4, type: 'numeric' },
    { data: 5, type: 'numeric' },
    { data: 6, type: 'numeric' },
    { data: 7, readOnly: true }  // hidden ID
  ],
  hiddenColumns: {
    columns: [7],
    indicators: false
  },
  rowHeaders: true,
  manualRowMove: true,
  copyPaste: true,
  contextMenu: {
    items: {
      "row_above": { name: "Insert row above" },
      "row_below": { name: "Insert row below" },
      "remove_row": { name: "Remove row" },
      "copy": { name: "Copy" },
      "paste": {
        name: "Paste",
        callback: async function() {
          try {
            const text = await navigator.clipboard.readText();
            if (!text) return;
            const cpPlugin = this.getPlugin('CopyPaste');
            cpPlugin.paste(text);
          } catch (err) {
            console.error("Error reading clipboard:", err);
            alert("Unable to paste. Your browser may require HTTPS or permission for clipboard access.");
          }
        }
      }
    }
  },
  licenseKey: 'non-commercial-and-evaluation'
});

let rowsToRemoveIDs = [];

// Hook to track which rows are removed
hot.addHook('beforeRemoveRow', (index, amount) => {
  rowsToRemoveIDs = [];
  for (let i = 0; i < amount; i++) {
    const rowData = hot.getDataAtRow(index + i);
    if (rowData && rowData[7] != null) {
      rowsToRemoveIDs.push(rowData[7]);
    }
  }
});

// After row removal, call the server to actually delete
hot.addHook('afterRemoveRow', (index, amount, source) => {
  if (rowsToRemoveIDs.length > 0) {
    const formData = new URLSearchParams();
    rowsToRemoveIDs.forEach(id => formData.append('ids[]', id));

    fetch('/delete_combos_hot', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: formData
    })
    .then(r => {
      if (!r.ok) {
        alert("Error deleting combos");
      } else {
        updateTotalCount(-amount);
        loadData();
      }
    });
  } else {
    loadData();
  }
});

// After row creation, call the server to insert
hot.addHook('afterCreateRow', (index, amount, source) => {
  let after_id = null;
  if (index > 0) {
    const prevRow = hot.getDataAtRow(index - 1);
    if (prevRow && prevRow[7] != null) {
      after_id = prevRow[7];
    }
  }
  fetch('/add_combo_hot', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ after_id: after_id || '' })
  }).then(r => {
    if (!r.ok) {
      alert("Invalid combo insert");
    } else {
      updateTotalCount(1);

      // IMPORTANT: we replicate the original logic so that after adding a row,
      // we jump to the new bottom page so the user sees it:
      offset = total_count - limit;
      if (offset < 0) offset = 0;
      loadData();
    }
  });
});

// After row move, reorder
hot.addHook('afterRowMove', (movedRows, finalIndex, dropIndex, movePossible, orderChanged) => {
  if (!orderChanged) return;
  const allData = hot.getData();
  const idsOrder = allData.map(r => r[7]).filter(x => x != null);
  const formData = new URLSearchParams();
  idsOrder.forEach(id => formData.append('new_order[]', id));

  fetch('/move_row_hot', {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: formData
  }).then(r => {
    if (!r.ok) {
      alert("Error moving row");
    } else {
      loadData();
    }
  });
});

// After a cell changes, update on server
hot.addHook('afterChange', (changes, source) => {
  if (!changes || loading) return;
  if (source === 'loadData') return;

  const changedRows = new Set();
  changes.forEach(([row, prop, oldVal, newVal]) => {
    if (oldVal !== newVal) {
      changedRows.add(row);
    }
  });
  if (changedRows.size === 0) return;

  let promises = [];
  changedRows.forEach(rowIndex => {
    const rowData = hot.getDataAtRow(rowIndex);
    const draw_id = rowData[7];
    if (draw_id != null) {
      const nums = {
        id: draw_id,
        num1: rowData[1],
        num2: rowData[2],
        num3: rowData[3],
        num4: rowData[4],
        num5: rowData[5],
        num6: rowData[6]
      };
      promises.push(
        fetch('/update_combo_hot', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams(nums)
        })
        .then(resp => {
          if (!resp.ok) alert("Invalid combo update");
        })
      );
    }
  });

  Promise.all(promises).then(() => loadData());
});

loadData();
</script>
{% endblock content %}

templates/index.html
{% extends "layout_no_sidebar.html" %}

{% block content %}
<div class="text-center">
    <h2>Toto Combinations Analyzer</h2>
    <div class="row mt-4">
        <div class="col-md-6 offset-md-3">
            <div class="card">
                <div class="card-header">
                    <h5>Select Game</h5>
                </div>
                <div class="card-body">
                    <div class="list-group">
                        {% for game_type, config in games.items() %}
                        <a href="{{ url_for('select_game', game_type=game_type) }}" class="list-group-item list-group-item-action">
                            {{ config.name }}
                        </a>
                        {% endfor %}
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

templates/layout.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Toto Combinations Analyzer</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/custom.css') }}">

    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <style>
        .sidebar {
            position: sticky;
            top: 0;
            background: #f8f9fa;
            border-right: 1px solid #ddd;
            padding: 1rem;
        }
        #combos-table thead th {
            position: sticky;
            top: 0;
            background: #ffffff;
            z-index: 10;
        }
        @media (min-width: 768px) {
            .sidebar {
                width: 250px;
            }
        }
        .main-content {
            flex-grow: 1;
        }
    </style>
</head>
<body class="bg-light">
    <!-- Navbar with brand (left), game label (center), back link (right) -->
    <nav class="navbar navbar-dark bg-dark mb-3">
        <div class="container-fluid d-flex justify-content-between align-items-center">

            <!-- Left: brand -->
            <a class="navbar-brand" href="{{ url_for('index') }}">
                Toto Combinations Analyzer
            </a>

            <!-- Center: game label (if any) -->
            <div class="text-light text-center flex-fill">
                {% if session.get('game_type') %}
                    <span style="font-weight: 500;">
                        {{ config.GAMES[session.get('game_type')]['name'] }}
                    </span>
                {% endif %}
            </div>

            <!-- Right: back link logic -->
            <div class="d-flex align-items-center">
                {% if request.endpoint == 'index' %}
                    <!-- On the index page, no back link -->

                {% elif request.endpoint == 'select_game' %}
                    <!-- On the select_game page, link back to index -->
                    <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                        Back to Game Selection
                    </a>

                {% else %}
                    {% if session.get('game_type') %}
                        <a href="{{ url_for('select_game', game_type=session['game_type']) }}"
                           class="btn btn-outline-light">
                            Back to Options
                        </a>
                    {% else %}
                        <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                            Back to Game Selection
                        </a>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <div class="row">
            <!-- Left Pane (sidebar) -->
            <div class="col-12 col-md-3 col-lg-2 sidebar">
                {% block sidebar %}{% endblock sidebar %}
            </div>

            <!-- Main Content -->
            <div class="col-12 col-md-9 col-lg-10 p-4 main-content">
                {% block content %}{% endblock content %}
            </div>
        </div>
    </div>
</body>
</html>

templates/layout_no_sidebar.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Toto Combinations Analyzer</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/custom.css') }}">

    <!-- JavaScript Libraries -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="{{ url_for('static', filename='js/main.js') }}"></script>

    <style>
        /* We remove the sidebar entirely */
        .main-centered {
            display: flex;
            justify-content: center;
        }
        .content-wrapper {
            max-width: 900px; /* adjustable */
            width: 100%;
        }
    </style>
</head>
<body class="bg-light">
    <!-- Navbar with brand (left), game label (center), back link (right) -->
    <nav class="navbar navbar-dark bg-dark mb-3">
        <div class="container-fluid d-flex justify-content-between align-items-center">

            <!-- Left: brand -->
            <a class="navbar-brand" href="{{ url_for('index') }}">
                Toto Combinations Analyzer
            </a>

            <!-- Right: back link logic -->
            <div class="d-flex align-items-center">
                {% if request.endpoint == 'index' %}
                    <!-- On the index page, no back link -->

                {% elif request.endpoint == 'select_game' %}
                    <!-- On the select_game page, link back to index -->
                    <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                        Back to Game Selection
                    </a>

                {% else %}
                    {% if session.get('game_type') %}
                        <a href="{{ url_for('select_game', game_type=session['game_type']) }}"
                           class="btn btn-outline-light">
                            Back to Options
                        </a>
                    {% else %}
                        <a href="{{ url_for('index') }}" class="btn btn-outline-light">
                            Back to Game Selection
                        </a>
                    {% endif %}
                {% endif %}
            </div>
        </div>
    </nav>

    <!-- Single-column, centered content -->
    <div class="container main-centered">
        <div class="content-wrapper">
            {% block content %}{% endblock content %}
        </div>
    </div>
</body>
</html>

templates/results.html
{% extends "layout.html" %}

{% block content %}
<h4>Toto Combinations Analyzer</h4>

{% if selected_df is none and top_df is none %}
<div class="alert alert-info">
    <p>Ready to run analysis. Adjust parameters and click "Run Analysis".</p>
</div>
{% endif %}

<div id="analysis-progress-container" style="display: none;" class="mt-2">
    <div class="d-flex align-items-center">
        <div class="spinner-border spinner-border-sm text-primary me-2" role="status" id="analysis-spinner"></div>
        <small id="analysis-status-text">Processing...</small>
    </div>
    <div class="progress mt-2" style="height: 4px;">
        <div class="progress-bar" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100" id="analysis-progress-bar"></div>
    </div>
    <small class="text-muted" id="analysis-progress-detail"></small>
</div>

<hr class="my-2">

<div id="results-container">
    {% if top_df is not none %}
    <small class="text-muted">Completed in {{ elapsed }} seconds.</small>

    <h6 class="mt-3 mb-2">{% if l == -1 %}Analysis Chain Results:{% else %}Top-ranked combinations:{% endif %}</h6>
    <table class="table table-sm table-striped table-hover">
        <thead>
            <tr>
                {% if l == -1 %}
                <th style="width: 100px;">Analysis #</th>
                <th style="width: 100px;">For Draw</th>
                {% endif %}
                <th style="width: 180px;">Combination</th>
                <th style="width: 100px;">Avg Rank</th>
                <th style="width: 100px;">Min Rank</th>
                {% if l == -1 %}
                <th style="width: 180px;">Top-Ranked Duration</th>
                {% endif %}
                <th>Subsets <small class="text-muted">(click to expand)</small></th>
            </tr>
        </thead>
        <tbody>
        {% for idx, row in top_df.iterrows() %}
            <tr>
                {% if l == -1 %}
                <td>{{ idx + 1 }}</td>
                <td>{{ row['Analysis Start Draw'] }}</td>
                {% endif %}
                <td>{{ row['Combination'] }}</td>
                <td>{{ "%.2f"|format(row['Average Rank']) }}</td>
                <td>{{ row['MinValue'] }}</td>
                {% if l == -1 %}
                <td>{{ row['Draws Until Common Subset'] }}</td>
                {% endif %}
                <td class="subset-cell">
                    <span class="subset-preview">{{ row['Subsets'][:50] }}...</span>
                    <span class="subset-full" style="display: none;">{{ row['Subsets'] }}</span>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>

    <a href="{{ url_for('download_top_csv') }}" class="btn btn-info btn-sm">Download Top CSV</a>

    {% if selected_df is not none %}
    <h6 class="mt-4 mb-2">Top-ranked combinations w/o overlapping subsets:</h6>
    <table class="table table-sm table-striped table-hover">
        <thead>
            <tr>
                <th style="width: 180px;">Combination</th>
                <th style="width: 100px;">Avg Rank</th>
                <th style="width: 100px;">Min Rank</th>
                <th>Subsets <small class="text-muted">(click to expand)</small></th>
            </tr>
        </thead>
        <tbody>
        {% for idx, row in selected_df.iterrows() %}
            <tr>
                <td>{{ row['Combination'] }}</td>
                <td>{{ "%.2f"|format(row['Average Rank']) }}</td>
                <td>{{ row['MinValue'] }}</td>
                <td class="subset-cell">
                    <span class="subset-preview">{{ row['Subsets'][:50] }}...</span>
                    <span class="subset-full" style="display: none;">{{ row['Subsets'] }}</span>
                </td>
            </tr>
        {% endfor %}
        </tbody>
    </table>
    <a href="{{ url_for('download_selected_csv') }}" class="btn btn-info btn-sm">Download Selected CSV</a>
    {% endif %}
    {% endif %}
</div>

<style>
.table { margin-bottom: 0.5rem; }
.table td, .table th { padding: 0.25rem 0.5rem; }
.subset-cell {
    cursor: pointer;
    font-size: 12px;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.subset-cell:hover {
    background-color: #f8f9fa;
}
.subset-cell.expanded {
    max-width: none;
    white-space: normal;
    word-break: break-all;
}
.subset-preview, .subset-full {
    font-family: monospace;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const runBtn = document.getElementById('run-analysis-btn');
    const progressContainer = document.getElementById('analysis-progress-container');
    const progressBar = document.getElementById('analysis-progress-bar');
    const statusText = document.getElementById('analysis-status-text');
    const progressDetail = document.getElementById('analysis-progress-detail');
    const resultsContainer = document.getElementById('results-container');

    let pollInterval = null;

    function createParams() {
        const params = new URLSearchParams();
        const offsetEl = document.getElementById('param-offset-last');
        let offsetVal = offsetEl ? offsetEl.value : "0";

        params.append('offset_last', offsetVal);
        params.append('j', document.getElementById('param-j').value);
        params.append('k', document.getElementById('param-k').value);
        params.append('m', document.getElementById('param-m').value);
        params.append('l', document.getElementById('param-l').value);
        params.append('n', document.getElementById('param-n').value);
        return params;
    }

    function startAnalysis() {
        resultsContainer.style.display = 'none';
        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';
        progressDetail.textContent = '';
        statusText.textContent = 'Processing...';

        fetch('/analysis_run', {
            method: 'POST',
            body: createParams()
        })
        .then(resp => {
            if (!resp.ok) throw new Error('Failed to start analysis');
            if (pollInterval) clearInterval(pollInterval);
            pollInterval = setInterval(checkProgress, 1000);
        })
        .catch(err => {
            alert("Failed to start analysis: " + err.message);
        });
    }

    function checkProgress() {
        fetch('/analysis_progress')
        .then(resp => {
            if (!resp.ok) throw new Error('Error fetching progress');
            return resp.json();
        })
        .then(data => {
            if (!data.in_progress && data.done) {
                clearInterval(pollInterval);
                pollInterval = null;
                statusText.textContent = 'Done!';
                progressBar.style.width = '100%';
                progressDetail.textContent = `Elapsed time: ${data.elapsed} seconds.`;

                const url = new URL('/analysis', window.location.href);
                const params = createParams();
                params.forEach((value, key) => url.searchParams.set(key, value));
                window.location.href = url.toString();
            } else {
                const p = data.processed;
                const t = data.total;
                let pct = (t > 0) ? Math.floor((p / t) * 100) : 0;
                progressBar.style.width = pct + '%';
            }
        })
        .catch(err => {
            console.error("Progress check error:", err);
            clearInterval(pollInterval);
        });
    }

    document.querySelectorAll('.subset-cell').forEach(cell => {
        cell.addEventListener('click', function() {
            const preview = this.querySelector('.subset-preview');
            const full = this.querySelector('.subset-full');
            const isExpanded = this.classList.contains('expanded');

            if (isExpanded) {
                preview.style.display = '';
                full.style.display = 'none';
                this.classList.remove('expanded');
            } else {
                preview.style.display = 'none';
                full.style.display = '';
                this.classList.add('expanded');
            }
        });
    });

    if (runBtn) {
        runBtn.addEventListener('click', startAnalysis);
    }
});
</script>

{% endblock content %}

{% block sidebar %}
<h5 class="mt-3">Parameters</h5>

<div class="mb-2">
    <label>Offset from last draw:</label>
    <input id="param-offset-last" type="number" class="form-control form-control-sm"
           value="{{ offset_last|default(0) }}">
</div>

<div class="mb-2">
    <label>n-number subsets of {{ game_config.max_number }}:</label>
    <input id="param-j" type="number" class="form-control form-control-sm" value="{{ j }}">
</div>

<div class="mb-2">
    <label>k-number subsets of n:</label>
    <input id="param-k" type="number" class="form-control form-control-sm" value="{{ k }}">
</div>

<div class="mb-2">
    <label>Sorting option:</label>
    <select id="param-m" class="form-select form-select-sm">
        <option value="avg" {% if m=='avg' %}selected{% endif %}>avg</option>
        <option value="min" {% if m=='min' or not m %}selected{% endif %}>min</option>
    </select>
</div>

<div class="mb-2">
    <label>Number of top-ranked combinations:</label>
    <input id="param-l" type="number" class="form-control form-control-sm" value="{{ l|default(1) }}">
</div>

<div class="mb-2">
    <label>Number of top-ranked combinations w/o overlapping subsets:</label>
    <input id="param-n" type="number" class="form-control form-control-sm" value="{{ n|default(0) }}">
</div>

<button id="run-analysis-btn" class="btn btn-danger btn-sm">Run Analysis</button>
{% endblock sidebar %}

analysis.py
# analysis.py
"""
analysis.py
-----------
This module orchestrates the analysis by calling a compiled C library (the "C_engine"),
thereby performing the same logic that existed in the Python-only approach but far more
quickly in C. The C library is loaded via ctypes.

Major points about this file:
1) We load the C library (libanalysis_engine.so on Linux) from the 'C_engine/src' folder.
2) We define a ctypes.Structure (AnalysisResultItem) mirroring the C struct that holds
   the analysis results.
3) We declare function signatures for run_analysis_c(...) and free_analysis_results(...)
   so that Python knows how to call into the C code.
4) In run_analysis(...), we read the draws from the database, prepare them in the format
   the C code expects, then invoke run_analysis_c(...).
5) We parse the returned pointers into Python objects and free the allocated results
   by calling free_analysis_results(...).
6) This approach preserves the original logic for "chain analysis" (l == -1) and "normal"
   top-l analysis (l >= 1), so that the final outcome matches your original Python results.
7) The only difference from the Python-only version is performance: this C-based code runs
   orders of magnitude faster, especially on larger sets of combos.

Important considerations:
- We do no partial progress reporting from the C code (the callback is effectively ignored).
- For chain analysis (l == -1), we return (selected_df=None, top_df=chain_results, elapsed).
- For normal analysis (l >= 1), we return (selected_df, top_df, elapsed).
- The "selected_df" portion is the "non-overlapping subsets" portion in the Python code;
  the C code lumps them into the second portion of the returned array, but we split them
  accordingly.
"""

import ctypes
import os
import time
import sqlite3
from database import get_db_connection
from config import Config

# ------------------------------------------------------------------------------
# 1) Load the compiled C library.
#    We assume the library is named 'libanalysis_engine.so' and is placed
#    in a subfolder "C_engine/src" next to this 'analysis.py'.
# ------------------------------------------------------------------------------
LIB_PATH = os.path.join(
    os.path.dirname(__file__),
    "C_engine", "src", "libanalysis_engine.so"
)
analysis_lib = ctypes.CDLL(LIB_PATH)

# ------------------------------------------------------------------------------
# 2) Define the AnalysisResultItem structure in Python
#    This must match the fields in analysis_engine.h
# ------------------------------------------------------------------------------
class AnalysisResultItem(ctypes.Structure):
    _fields_ = [
        ("combination", ctypes.c_char * 256),
        ("avg_rank", ctypes.c_double),
        ("min_value", ctypes.c_double),
        ("subsets", ctypes.c_char * 512),
        ("draw_offset", ctypes.c_int),
        ("draws_until_common", ctypes.c_int),
        ("analysis_start_draw", ctypes.c_int),
        ("is_chain_result", ctypes.c_int),
    ]

# ------------------------------------------------------------------------------
# 3) Tell ctypes about the run_analysis_c(...) function signature
# ------------------------------------------------------------------------------
analysis_lib.run_analysis_c.argtypes = [
    ctypes.c_char_p,                               # const char* game_type
    ctypes.POINTER(ctypes.POINTER(ctypes.c_int)),  # int** draws
    ctypes.c_int,                                  # draws_count
    ctypes.c_int,                                  # j
    ctypes.c_int,                                  # k
    ctypes.c_char_p,                               # m
    ctypes.c_int,                                  # l
    ctypes.c_int,                                  # n
    ctypes.c_int,                                  # last_offset
    ctypes.POINTER(ctypes.c_int)                   # out_len (pointer)
]
analysis_lib.run_analysis_c.restype = ctypes.POINTER(AnalysisResultItem)

# ------------------------------------------------------------------------------
# 4) Tell ctypes about the free_analysis_results(...) function signature
# ------------------------------------------------------------------------------
analysis_lib.free_analysis_results.argtypes = [ctypes.POINTER(AnalysisResultItem)]
analysis_lib.free_analysis_results.restype = None


# ------------------------------------------------------------------------------
# 5) The main function called by app.py to run the analysis
# ------------------------------------------------------------------------------
def run_analysis(game_type='6_42', j=6, k=3, m='min', l=1, n=0,
                 last_offset=0,
                 progress_callback=None,
                 should_stop=lambda: False):
    """
    This function replicates your Python "analysis" logic but uses the C engine
    for all heavy computations.

    Parameters:
    -----------
    game_type : str  (e.g. '6_42')
    j         : int  (the 'n-number subsets' or 'j' in the original code)
    k         : int  (the 'k-number subsets of n')
    m         : str  (sorting option, 'avg' or 'min')
    l         : int  (number of top-ranked combos, or -1 for chain analysis)
    n         : int  (number of top-ranked combos w/o overlapping subsets)
    last_offset : int (offset from the last draw, used in both chain & normal)
    progress_callback : function (ignored here, we do not do partial updates in C)
    should_stop : function (ignored as well for simplicity in C)

    Returns:
    --------
    (selected_df, top_df, elapsed_seconds)

    Where:
      - For chain analysis (l == -1), top_df is actually the chain results,
        selected_df is None.
      - For normal analysis (l >= 1), top_df is the top-l combos, selected_df
        is the additional "non-overlapping" portion (up to n combos).
      - elapsed_seconds is an int giving total time spent.

    Raises:
    -------
    OSError if the .so library isn't found or can't be loaded.
    """
    start_time = time.time()

    # 1) Load draws from the DB
    conn = get_db_connection(game_type)
    c = conn.cursor()
    row_count = c.execute("SELECT COUNT(*) as cnt FROM draws").fetchone()["cnt"]

    # Constrain last_offset to [0, row_count]
    if last_offset < 0:
        last_offset = 0
    if last_offset > row_count:
        last_offset = row_count

    # Actually fetch the draws
    draws = c.execute(
        "SELECT number1, number2, number3, number4, number5, number6 FROM draws ORDER BY sort_order"
    ).fetchall()
    conn.close()

    draws_count = len(draws)

    # 2) Convert these draws into an array-of-pointers for the C library
    draws_c = (ctypes.POINTER(ctypes.c_int) * draws_count)()
    for i, row in enumerate(draws):
        row_arr = (ctypes.c_int * 6)()
        # If any row element is None, we clamp it to 1 or some fallback
        for jx in range(6):
            row_arr[jx] = row[jx] if row[jx] is not None else 1
        draws_c[i] = row_arr

    # 3) Prepare out_len
    out_len = ctypes.c_int(0)

    # 4) Call the C function
    results_ptr = analysis_lib.run_analysis_c(
        game_type.encode('utf-8'),  # const char*
        draws_c,                    # int** draws
        draws_count,                # draws_count
        j,                          # j
        k,                          # k
        m.encode('utf-8'),         # m
        l,                          # l
        n,                          # n
        last_offset,                # last_offset
        ctypes.byref(out_len)       # out_len
    )

    res_count = out_len.value

    # 5) Convert the returned results into Python objects
    if not results_ptr or res_count <= 0:
        # No results or error
        elapsed = round(time.time() - start_time)
        return None, None, elapsed

    python_results = []
    for i in range(res_count):
        item = results_ptr[i]
        python_results.append({
            "combination": item.combination.decode('utf-8'),
            "avg_rank": item.avg_rank,
            "min_value": item.min_value,
            "subsets": item.subsets.decode('utf-8'),
            "draw_offset": item.draw_offset,
            "draws_until_common": item.draws_until_common,
            "analysis_start_draw": item.analysis_start_draw,
            "is_chain_result": item.is_chain_result
        })

    # 6) Free the results in C
    analysis_lib.free_analysis_results(results_ptr)

    # 7) Build Pandas DataFrames in the same shape as the original code expects
    import pandas as pd
    elapsed = round(time.time() - start_time)

    # Chain analysis
    if l == -1:
        # If chain analysis, just return them all in top_df
        chain_data = []
        for row in python_results:
            chain_data.append({
                'Offset': row['draw_offset'],
                'Combination': row['combination'],
                'Average Rank': row['avg_rank'],
                'MinValue': row['min_value'],
                'Subsets': row['subsets'],
                'Draws Until Common Subset': row['draws_until_common'],
                'Analysis Start Draw': row['analysis_start_draw'],
                'Draw Count': row['draw_offset']
            })
        if len(chain_data) == 0:
            return None, None, elapsed
        top_df = pd.DataFrame(chain_data)
        selected_df = None
        return selected_df, top_df, elapsed

    # Normal analysis
    else:
        # The C code arranges the top-l combos first, then up to n "selected" combos next
        top_data = []
        selected_data = []
        # figure out the boundary
        # If we had "filled" combos for top-l in C, that count is min(l, actual).
        # Then "n" combos follow for the "selected" portion, if any.
        # So we do the same split here:
        top_count = min(l, res_count)
        for i in range(top_count):
            r = python_results[i]
            top_data.append({
                'Combination': r['combination'],
                'Average Rank': r['avg_rank'],
                'MinValue': r['min_value'],
                'Subsets': r['subsets']
            })
        if n > 0 and res_count > top_count:
            selected_count = min(n, res_count - top_count)
            for i in range(top_count, top_count + selected_count):
                r = python_results[i]
                selected_data.append({
                    'Combination': r['combination'],
                    'Average Rank': r['avg_rank'],
                    'MinValue': r['min_value'],
                    'Subsets': r['subsets']
                })

        top_df = pd.DataFrame(top_data) if top_data else None
        selected_df = pd.DataFrame(selected_data) if selected_data else None
        return selected_df, top_df, elapsed

app.py
# app.py
"""
app.py
------
This is the Flask application entry point. It handles:
- Session setup
- Routing for pages (index, select_game, combos, analysis, etc.)
- Database I/O for combos
- The analysis run invocation
- The progress endpoint (although we no longer do partial progress from C)

Key changes compared to the original (Python-based) analysis approach:
- We import 'run_analysis' from the new analysis.py, which calls the C library.
- For partial-progress updates, we no longer do them, but we keep the endpoints
  so your UI remains functional (the progress just jumps from 0% to done).

We have ensured that the route "combos" logic is the same as the original:
- If "offset" is missing, jump to the last page automatically.
Otherwise, we respect the offset. This ensures you can "see the combos."

The 'analysis_run' route spawns a thread that calls run_analysis(...).
We store the results in global variables 'analysis_selected_df' and
'analysis_top_df' to be displayed by the /analysis route. This matches
the original structure so your UI doesn't break.
"""

import os
import io
import pandas as pd
import threading
import time

from flask import Flask, render_template, request, make_response, jsonify, redirect, url_for, session
from flask_session import Session

from database import *
from analysis import run_analysis
from config import Config

app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key-here'
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = False
Session(app)

analysis_in_progress = False
analysis_processed = 0
analysis_total = 0
analysis_selected_df = None
analysis_top_df = None
analysis_elapsed = None
analysis_thread = None
analysis_cancel_requested = False

@app.context_processor
def utility_processor():
    return dict(config=Config)

@app.route('/')
def index():
    """
    The home page: lists all available games, e.g. 6/42, 6/49, etc.
    """
    return render_template('index.html', games=Config.GAMES)

@app.route('/select_game/<game_type>')
def select_game(game_type):
    """
    Store the selected game in the session, then show the game options:
    'View/Edit Combinations' and 'Run Analysis'.
    """
    if game_type not in Config.GAMES:
        return redirect(url_for('index'))
    session['game_type'] = game_type
    game_config = Config.GAMES[game_type]
    return render_template('game_options.html', game_type=game_type, game_config=game_config)

@app.route('/combos', methods=['GET'])
def combos():
    """
    Shows the combos page with Handsontable.
    We preserve the original logic:
      - If no 'offset' is provided, jump to the bottom (last page).
      - If 'offset' is explicitly set, we use that.
    """
    game_type = session.get('game_type', '6_42')
    if not game_type:
        return redirect(url_for('index'))

    limit = request.args.get('limit', 20, type=int)
    offset_param = request.args.get('offset', None)
    total_count = count_draws(game_type)

    if offset_param is None:
        # Jump to last page
        offset = max(total_count - limit, 0)
    else:
        offset = int(offset_param)

    return render_template(
        'combos.html',
        limit=limit,
        offset=offset,
        total_count=total_count,
        game_config=Config.GAMES[game_type]
    )

@app.route('/combos_data', methods=['GET'])
def combos_data():
    """
    Endpoint that returns JSON data for the combos in the specified limit/offset.
    The JavaScript in combos.html loads this data into Handsontable.
    """
    game_type = session.get('game_type', '6_42')
    limit = request.args.get('limit', 20, type=int)
    offset = request.args.get('offset', 0, type=int)
    draws = get_draws(game_type, limit=limit, offset=offset)
    data = []
    for d in draws:
        data.append([
            d['draw_number'],
            d['number1'],
            d['number2'],
            d['number3'],
            d['number4'],
            d['number5'],
            d['number6'],
            d['id']
        ])
    return jsonify(data)

@app.route('/update_combo_hot', methods=['POST'])
def update_combo_hot():
    """
    Called by the Handsontable afterChange hook to update a row.
    """
    game_type = session.get('game_type', '6_42')
    draw_id = request.form.get('id', type=int)
    nums = [
        request.form.get('num1', type=int),
        request.form.get('num2', type=int),
        request.form.get('num3', type=int),
        request.form.get('num4', type=int),
        request.form.get('num5', type=int),
        request.form.get('num6', type=int),
    ]
    update_draw(draw_id, nums, game_type)
    return "OK"

@app.route('/add_combo_hot', methods=['POST'])
def add_combo_hot():
    """
    Called by the Handsontable 'afterCreateRow' hook to insert a new row.
    We place it after a given ID if provided, then re-run renumbering.
    """
    game_type = session.get('game_type', '6_42')
    after_id = request.form.get('after_id', type=int)
    insert_draw([None, None, None, None, None, None], game_type, after_id=after_id)
    return "OK"

@app.route('/delete_combos_hot', methods=['POST'])
def delete_combos_hot():
    """
    Called when the user removes rows in Handsontable.
    We delete each ID from the DB, then renumber.
    """
    game_type = session.get('game_type', '6_42')
    ids = request.form.getlist('ids[]', type=int)
    if not ids:
        return "No IDs", 400
    delete_draws(ids, game_type)
    return "OK"

@app.route('/move_row_hot', methods=['POST'])
def move_row_hot():
    """
    Called after a user manually reorders rows in Handsontable.
    We reorder 'sort_order' accordingly, then renumber them so that
    draw_number fields remain consistent.
    """
    game_type = session.get('game_type', '6_42')
    new_order = request.form.getlist('new_order[]', type=int)
    conn = get_db_connection(game_type)
    c = conn.cursor()
    for i, id_val in enumerate(new_order, start=1):
        c.execute("UPDATE draws SET sort_order=? WHERE id=?", (i, id_val))
    conn.commit()
    conn.close()
    renumber_all(game_type)
    return "OK"

@app.route('/download_all_combos', methods=['GET'])
def download_all_combos():
    """
    Let users download all combos as CSV.
    """
    game_type = session.get('game_type', '6_42')
    rows = get_all_draws(game_type)
    df = pd.DataFrame([
        [
            row['draw_number'],
            row['number1'],
            row['number2'],
            row['number3'],
            row['number4'],
            row['number5'],
            row['number6']
        ]
        for row in rows
    ], columns=['Draw', '#1', '#2', '#3', '#4', '#5', '#6'])
    output = io.StringIO()
    df.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=all_combos.csv"
    response.headers["Content-type"] = "text/csv"
    return response

@app.route('/analysis_start', methods=['GET'])
def analysis_start():
    """
    Renders the analysis page (results.html) with empty results, ready for user parameters.
    """
    game_type = session.get('game_type', '6_42')
    if not game_type:
        return redirect(url_for('index'))
    game_config = Config.GAMES[game_type]
    j_default = 6
    return render_template(
        'results.html',
        game_config=game_config,
        selected_df=None,
        top_df=None,
        elapsed=None,
        j=j_default,
        k=3,
        m='min',
        l=1,
        n=0,
        offset_last=0
    )

@app.route('/analysis')
def analysis_route():
    """
    Once the analysis thread finishes, it stores the results in analysis_selected_df
    and analysis_top_df, plus analysis_elapsed. We display them here.
    """
    game_type = session.get('game_type', '6_42')
    j = request.args.get('j', 6, type=int)
    k = request.args.get('k', 3, type=int)
    m = request.args.get('m', 'min')
    l = request.args.get('l', 1, type=int)
    n_val = request.args.get('n', 0, type=int)
    offset_last = request.args.get('offset_last', 0, type=int)

    global analysis_selected_df, analysis_top_df, analysis_elapsed
    return render_template(
        'results.html',
        j=j, k=k, m=m, l=l, n=n_val,
        offset_last=offset_last,
        selected_df=analysis_selected_df,
        top_df=analysis_top_df,
        elapsed=analysis_elapsed,
        game_config=Config.GAMES[game_type]
    )

@app.route('/analysis_run', methods=['POST'])
def analysis_run():
    """
    Starts the analysis in a separate thread so we can poll for progress (though
    we do not get partial updates from the C code, so the progress just goes 0 -> done).
    """
    global analysis_in_progress, analysis_processed, analysis_total
    global analysis_selected_df, analysis_top_df, analysis_elapsed
    global analysis_thread, analysis_cancel_requested

    game_type = session.get('game_type', '6_42')
    j = request.form.get('j', type=int, default=6)
    k = request.form.get('k', type=int, default=3)
    m = request.form.get('m', type=str, default='min')
    l = request.form.get('l', type=int, default=1)
    n_val = request.form.get('n', type=int, default=0)
    offset_val = request.form.get('offset_last', type=int, default=0)

    # If there's an existing analysis, cancel it
    if analysis_in_progress:
        analysis_cancel_requested = True
        if analysis_thread and analysis_thread.is_alive():
            analysis_thread.join()
        analysis_cancel_requested = False
        analysis_in_progress = False

    analysis_in_progress = True
    analysis_processed = 0
    analysis_total = 0
    analysis_selected_df = None
    analysis_top_df = None
    analysis_elapsed = None

    def worker():
        global analysis_in_progress, analysis_selected_df, analysis_top_df, analysis_elapsed
        sel_df, top_df, elapsed = run_analysis(
            game_type=game_type,
            j=j, k=k, m=m, l=l, n=n_val,
            last_offset=offset_val
        )
        analysis_selected_df = sel_df
        analysis_top_df = top_df
        analysis_elapsed = elapsed
        analysis_in_progress = False

    analysis_thread = threading.Thread(target=worker)
    analysis_thread.start()
    return "OK"

@app.route('/analysis_progress', methods=['GET'])
def analysis_progress():
    """
    Our UI polls this endpoint for progress. We do not have partial updates from C,
    so we simply return 'done' or not. Once the C code finishes, 'done' is true.
    """
    global analysis_in_progress, analysis_processed, analysis_total, analysis_elapsed
    resp = {
        'in_progress': analysis_in_progress,
        'processed': analysis_processed,
        'total': analysis_total,
        'done': (not analysis_in_progress) and (analysis_elapsed is not None),
        'elapsed': analysis_elapsed
    }
    return jsonify(resp)

################################################################################
# ADD THESE TWO MISSING ROUTES BELOW TO MATCH THE ORIGINAL FUNCTIONALITY
################################################################################

@app.route('/download_top_csv', methods=['GET'])
def download_top_csv():
    """
    Let users download the 'top combos' as a CSV file,
    matching the original code's functionality.
    """
    global analysis_top_df
    if analysis_top_df is None:
        return "No analysis run yet", 400
    output = io.StringIO()
    analysis_top_df.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=top_combinations.csv"
    response.headers["Content-type"] = "text/csv"
    return response

@app.route('/download_selected_csv', methods=['GET'])
def download_selected_csv():
    """
    Let users download the 'selected combos' (non-overlapping subsets) as CSV,
    matching the original code's functionality.
    """
    global analysis_selected_df
    if analysis_selected_df is None:
        return "No analysis run yet", 400
    output = io.StringIO()
    analysis_selected_df.to_csv(output, index=False)
    output.seek(0)
    response = make_response(output.getvalue())
    response.headers["Content-Disposition"] = "attachment; filename=selected_combinations.csv"
    response.headers["Content-type"] = "text/csv"
    return response


if __name__ == '__main__':
    # Typically run with "python app.py" or "gunicorn app:app"
    port = int(os.environ.get("PORT", 10000))
    app.run(host='0.0.0.0', port=port, debug=False)

database.py
# database.py
"""
database.py
-----------
Provides database-related functions for storing and retrieving TOTO combos
and draws. Each game type (like '6_42') has its own SQLite database file
(e.g., 'toto_6_42_draws.db').

Key points:
-----------
1) get_db_connection(game_type) returns a sqlite3 connection to the
   corresponding DB, using row_factory for convenience.
2) renumber_all(game_type) reassigns 'sort_order' and 'draw_number' so that
   each row is ordered consistently. This is called after any insertion
   or reordering operation.
3) get_draws(...) fetches a chunk of draws in ascending order by sort_order,
   applying a limit and offset.
4) count_draws(...) gives the total count for pagination.
5) insert_draw(numbers, game_type, after_id) inserts a new draw,
   placing it after a given ID's sort_order if provided, then calls renumber_all.
6) delete_draws(ids, game_type) deletes draws by ID and calls renumber_all.
7) update_draw(...) updates a draw's numbers, clamping them to [1..max_number].
8) get_all_draws(...) fetches all draws to generate CSV for "Download All" feature.

No functional differences from your original code aside from ensuring
everything stays consistent with the new analysis code.
"""

import sqlite3
import pandas as pd
from config import Config

def get_db_connection(game_type='6_42'):
    db_path = Config.GAMES[game_type]['db_name']
    conn = sqlite3.connect(db_path, timeout=5)
    conn.row_factory = sqlite3.Row
    return conn

def renumber_all(game_type='6_42'):
    conn = get_db_connection(game_type)
    c = conn.cursor()
    rows = c.execute("SELECT id FROM draws ORDER BY sort_order").fetchall()
    for i, row in enumerate(rows, start=1):
        draw_number = f"{i:04d}"
        c.execute("UPDATE draws SET sort_order=?, draw_number=? WHERE id=?",
                  (i, draw_number, row['id']))
    conn.commit()
    conn.close()

def get_draws(game_type='6_42', limit=100, offset=0):
    conn = get_db_connection(game_type)
    draws = conn.execute(
        "SELECT * FROM draws ORDER BY sort_order LIMIT ? OFFSET ?",
        (limit, offset)
    ).fetchall()
    conn.close()
    return draws

def count_draws(game_type='6_42'):
    conn = get_db_connection(game_type)
    count = conn.execute("SELECT COUNT(*) as cnt FROM draws").fetchone()["cnt"]
    conn.close()
    return count

def insert_draw(numbers, game_type='6_42', after_id=None):
    numbers = clamp_numbers(numbers, game_type)
    conn = get_db_connection(game_type)
    c = conn.cursor()

    if after_id:
        row = c.execute("SELECT sort_order FROM draws WHERE id=?", (after_id,)).fetchone()
        if row:
            after_sort = row["sort_order"]
            c.execute("UPDATE draws SET sort_order = sort_order + 1 WHERE sort_order > ?", (after_sort,))
            new_sort_order = after_sort + 1
        else:
            max_so = c.execute("SELECT MAX(sort_order) FROM draws").fetchone()[0]
            new_sort_order = (max_so or 0) + 1
    else:
        max_so = c.execute("SELECT MAX(sort_order) FROM draws").fetchone()[0]
        new_sort_order = (max_so or 0) + 1

    draw_number = "temp"
    c.execute('''
        INSERT INTO draws (draw_number, number1, number2, number3, number4, number5, number6, sort_order)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (draw_number, *numbers, new_sort_order))
    conn.commit()
    conn.close()

    renumber_all(game_type)

def delete_draws(ids, game_type='6_42'):
    conn = get_db_connection(game_type)
    q_marks = ",".join("?" for _ in ids)
    sql = f"DELETE FROM draws WHERE id IN ({q_marks})"
    conn.execute(sql, ids)
    conn.commit()
    conn.close()
    renumber_all(game_type)

def update_draw(draw_id, numbers, game_type='6_42'):
    numbers = clamp_numbers(numbers, game_type)
    conn = get_db_connection(game_type)
    conn.execute('''
        UPDATE draws
        SET number1=?, number2=?, number3=?, number4=?, number5=?, number6=?
        WHERE id=?
    ''', (*numbers, draw_id))
    conn.commit()
    conn.close()

def get_all_draws(game_type='6_42'):
    conn = get_db_connection(game_type)
    rows = conn.execute("SELECT * FROM draws ORDER BY sort_order").fetchall()
    conn.close()
    return rows

def clamp_numbers(nums, game_type='6_42'):
    max_number = Config.GAMES[game_type]['max_number']
    cleaned = []
    for n in nums:
        if n is None:
            cleaned.append(None)
        else:
            if n < 1:
                n = 1
            if n > max_number:
                n = max_number
            cleaned.append(n)
    return cleaned

init_database.py
# init_database.py
import pandas as pd
import sqlite3
import sys
from config import Config

def init_db(game_type):
    game_config = Config.GAMES[game_type]
    max_number = game_config['max_number']
    conn = sqlite3.connect(game_config['db_name'])
    c = conn.cursor()

    c.execute('DROP TABLE IF EXISTS draws')

    max_number = game_config['max_number']
    c.execute(f'''
        CREATE TABLE draws (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            draw_number TEXT,
            number1 INTEGER CHECK (number1 IS NULL OR (number1 >= 1 AND number1 <= {max_number})),
            number2 INTEGER CHECK (number2 IS NULL OR (number2 >= 1 AND number2 <= {max_number})),
            number3 INTEGER CHECK (number3 IS NULL OR (number3 >= 1 AND number3 <= {max_number})),
            number4 INTEGER CHECK (number4 IS NULL OR (number4 >= 1 AND number4 <= {max_number})),
            number5 INTEGER CHECK (number5 IS NULL OR (number5 >= 1 AND number5 <= {max_number})),
            number6 INTEGER CHECK (number6 IS NULL OR (number6 >= 1 AND number6 <= {max_number})),
            sort_order INTEGER
        )
    ''')

    conn.commit()
    return conn

def load_csv_to_db(game_type):
    try:
        game_config = Config.GAMES[game_type]
        df = pd.read_csv(game_config['csv_file'], header=None)
        df = df.iloc[1:].reset_index(drop=True)
        df['draw_number'] = df.index.map(lambda x: f'{x+1:04d}')

        conn = init_db(game_type)
        cursor = conn.cursor()

        for index, row in df.iterrows():
            numbers = sorted(row.iloc[:6].astype(int).tolist())
            draw_number = row['draw_number']
            cursor.execute('''
                INSERT INTO draws (draw_number, number1, number2, number3, number4, number5, number6)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            ''', (draw_number, *numbers))

        cursor.execute("UPDATE draws SET sort_order = id")
        conn.commit()
        conn.close()

        print(f"Successfully loaded {len(df)} draws into {game_config['db_name']}")
        return True
    except Exception as e:
        print(f"Error: {str(e)}")
        return False

if __name__ == "__main__":
    for game_type in Config.GAMES:
        print(f"\nInitializing database for {Config.GAMES[game_type]['name']}...")
        success = load_csv_to_db(game_type)
        if not success:
            sys.exit(1)

config.py
# config.py (new file)
class Config:
    GAMES = {
        '6_42': {
            'name': 'Toto 6/42',
            'max_number': 42,
            'db_name': 'toto_6_42_draws.db',
            'csv_file': 'Toto_6_42_with_first_row.csv'
        },
        '6_49': {
            'name': 'Toto 6/49',
            'max_number': 49,
            'db_name': 'toto_6_49_draws.db',
            'csv_file': 'Toto_6_49_with_first_row.csv'
        }
    }

requirements.txt
gunicorn==21.2.0
Flask==2.2.2
pandas==1.5.3
statistics;python_version<"3.10"
seaborn==0.12.0
tqdm==4.66.1
Flask-Session==0.5.0
numpy==1.23.2
itsdangerous==2.0.0
Werkzeug==2.2.2
click==8.0.0
Jinja2==3.0.0
MarkupSafe==2.1.1

C_engine/src/analysis_engine.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>

#include "analysis_engine.h"

#define MAX_COMBO_STR 255
#define MAX_SUBSETS_STR 511
#define MAX_ALLOWED_J 200
#define MAX_ALLOWED_OUT_LEN 1000000
#define MAX_NUMBERS 50  // Max supported numbers (for 6/49 and 6/42)
#define LOOKUP_BITS 16  // For subset indexing optimization

typedef unsigned long long uint64;
typedef unsigned int uint32;

// Pre-computed lookup tables
static uint64 choose_table[MAX_NUMBERS][MAX_NUMBERS];
static int initialized = 0;

// Initialize combinatorial lookup table
static void init_lookup_tables() {
    if (initialized) return;
    memset(choose_table, 0, sizeof(choose_table));
    for (int n = 0; n < MAX_NUMBERS; n++) {
        choose_table[n][0] = 1;
        for (int k = 1; k <= n; k++) {
            choose_table[n][k] = choose_table[n-1][k-1] + choose_table[n-1][k];
        }
    }
    initialized = 1;
}

// Fast subset rank computation using bit manipulation
static uint64 subset_rank(const int* subset, int k, int max_number) {
    uint64 rank = 0;
    int prev = 0;
    for (int i = 0; i < k; i++) {
        int curr = subset[i] - 1;  // Convert to 0-based
        if (curr > prev) {
            for (int j = prev + 1; j < curr; j++) {
                rank += choose_table[max_number - j - 1][k - i - 1];
            }
        }
        prev = curr;
    }
    return rank;
}

// Fast bit manipulation for subset checking
static inline uint64 to_bitmask(const int* numbers, int count) {
    uint64 mask = 0;
    for (int i = 0; i < count; i++) {
        mask |= 1ULL << (numbers[i] - 1);
    }
    return mask;
}

// Structure to track subset occurrences efficiently
typedef struct {
    int* last_seen;        // When each subset was last seen
    int max_subsets;       // Total possible k-subsets
    int draws_count;       // Total draws being analyzed
    int k;                 // k-size for subsets
    int max_number;        // Maximum number (42 or 49)
} SubsetTracker;

static SubsetTracker* create_tracker(int max_number, int k, int draws_count) {
    SubsetTracker* t = (SubsetTracker*)malloc(sizeof(SubsetTracker));
    t->max_number = max_number;
    t->k = k;
    t->draws_count = draws_count;
    t->max_subsets = (int)choose_table[max_number][k];
    t->last_seen = (int*)malloc(t->max_subsets * sizeof(int));

    // Initialize all subsets as never seen
    for (int i = 0; i < t->max_subsets; i++) {
        t->last_seen[i] = draws_count;
    }
    return t;
}

static void free_tracker(SubsetTracker* t) {
    if (!t) return;
    free(t->last_seen);
    free(t);
}

// Track when each k-subset was last seen
static void update_tracker(SubsetTracker* t, const int* numbers, int draw_idx) {
    static int subset[20];
    int n = 6;  // numbers length (always 6 for TOTO)
    int k = t->k;

    // Generate all k-subsets of the numbers and update their last seen index
    int c[20];
    for (int i = 0; i < k; i++) c[i] = i;

    while (1) {
        for (int i = 0; i < k; i++) subset[i] = numbers[c[i]];

        uint64 rank = subset_rank(subset, k, t->max_number);
        if (rank < t->max_subsets &&
            (t->last_seen[rank] > draw_idx)) {
            t->last_seen[rank] = draw_idx;
        }

        // Generate next combination
        int i = k - 1;
        while (i >= 0 && c[i] == n - k + i) i--;
        if (i < 0) break;
        c[i]++;
        for (int j = i + 1; j < k; j++) c[j] = c[i] + j - i;
    }
}

// Structure to hold combo statistics
typedef struct {
    int combo[64];
    int combo_len;
    double avg_rank;
    double min_rank;
    int total_draws;
} ComboStats;

// Evaluate a single combination
static void evaluate_combo(
    const int* combo,
    int j,
    int k,
    SubsetTracker* t,
    ComboStats* stats
) {
    static int subset[20];
    long long sum_ranks = 0;
    double min_rank = t->draws_count + 1;
    int count = 0;

    // Generate all k-subsets of the combo
    int c[20];
    for (int i = 0; i < k; i++) c[i] = i;

    while (1) {
        for (int i = 0; i < k; i++) subset[i] = combo[c[i]];

        uint64 rank = subset_rank(subset, k, t->max_number);
        int last_seen = (rank < t->max_subsets) ? t->last_seen[rank] : t->draws_count;

        double rank_val = last_seen + 1;
        sum_ranks += rank_val;
        if (rank_val < min_rank) min_rank = rank_val;
        count++;

        // Generate next combination
        int i = k - 1;
        while (i >= 0 && c[i] == j - k + i) i--;
        if (i < 0) break;
        c[i]++;
        for (int j = i + 1; j < k; j++) c[j] = c[i] + j - i;
    }

    stats->avg_rank = (double)sum_ranks / count;
    stats->min_rank = min_rank;
    stats->total_draws = t->draws_count;
}

// Format subset information for display
static void format_subsets(
    const int* combo,
    int j,
    int k,
    SubsetTracker* t,
    char* out_buf
) {
    static int subset[20];
    char* ptr = out_buf;
    int remaining = MAX_SUBSETS_STR;

    ptr += snprintf(ptr, remaining, "[");
    remaining = MAX_SUBSETS_STR - (ptr - out_buf);

    int c[20];
    for (int i = 0; i < k; i++) c[i] = i;
    int first = 1;

    while (1 && remaining > 0) {
        for (int i = 0; i < k; i++) subset[i] = combo[c[i]];

        uint64 rank = subset_rank(subset, k, t->max_number);
        int last_seen = (rank < t->max_subsets) ? t->last_seen[rank] : t->draws_count;

        if (!first) {
            ptr += snprintf(ptr, remaining, ", ");
            remaining = MAX_SUBSETS_STR - (ptr - out_buf);
        }
        first = 0;

        ptr += snprintf(ptr, remaining, "((");
        for (int i = 0; i < k; i++) {
            ptr += snprintf(ptr, remaining, "%d%s", subset[i], i < k-1 ? "," : "");
        }
        ptr += snprintf(ptr, remaining, "), %d)", last_seen + 1);
        remaining = MAX_SUBSETS_STR - (ptr - out_buf);

        int i = k - 1;
        while (i >= 0 && c[i] == j - k + i) i--;
        if (i < 0) break;
        c[i]++;
        for (int j = i + 1; j < k; j++) c[j] = c[i] + j - i;
    }

    snprintf(ptr, remaining, "]");
}

static void combo_to_string(const int* combo, int len, char* out) {
    char* ptr = out;
    int remaining = MAX_COMBO_STR;

    for (int i = 0; i < len; i++) {
        int written = snprintf(ptr, remaining, "%d%s", combo[i], i < len-1 ? "," : "");
        ptr += written;
        remaining -= written;
        if (remaining <= 0) break;
    }
}

AnalysisResultItem* run_analysis_c(
    const char* game_type,
    int** draws,
    int draws_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int last_offset,
    int* out_len
) {
    if (!initialized) init_lookup_tables();

    if (j > MAX_ALLOWED_J) {
        fprintf(stderr, "Error: j=%d exceeds safety limit %d.\n", j, MAX_ALLOWED_J);
        *out_len = 0;
        return NULL;
    }

    int max_number = strstr(game_type, "6_49") ? 49 : 42;
    *out_len = 0;

    // Sort numbers within each draw
    for (int i = 0; i < draws_count; i++) {
        for (int a = 0; a < 5; a++) {
            for (int b = a + 1; b < 6; b++) {
                if (draws[i][a] > draws[i][b]) {
                    int tmp = draws[i][a];
                    draws[i][a] = draws[i][b];
                    draws[i][b] = tmp;
                }
            }
        }
    }

    int use_count = draws_count - last_offset;
    if (use_count < 1) return NULL;

    // Create and populate subset tracker
    SubsetTracker* tracker = create_tracker(max_number, k, use_count);
    for (int i = 0; i < use_count; i++) {
        update_tracker(tracker, draws[i], i);
    }

    // Allocate space for results
    int capacity = (l == -1) ? 1000 : (l + n);
    AnalysisResultItem* results = (AnalysisResultItem*)calloc(capacity, sizeof(AnalysisResultItem));

    if (l == -1) {
        // Chain analysis
        int current_offset = last_offset;

        while (current_offset >= 0 && current_offset < draws_count) {
            int use_count = draws_count - current_offset;
            if (use_count < 1) break;

            // Find best combination
            ComboStats best_stats;
            memset(&best_stats, 0, sizeof(ComboStats));
            best_stats.min_rank = tracker->draws_count + 1;
            int best_combo[64];

            int* curr_combo = (int*)malloc(j * sizeof(int));
            for (int i = 0; i < j; i++) curr_combo[i] = i + 1;

            do {
                ComboStats stats;
                evaluate_combo(curr_combo, j, k, tracker, &stats);

                int better;
                if (strcmp(m, "avg") == 0) {
                    better = (stats.avg_rank < best_stats.avg_rank) ||
                            (best_stats.avg_rank == 0);
                } else {
                    better = (stats.min_rank < best_stats.min_rank) ||
                            (best_stats.min_rank == tracker->draws_count + 1);
                }

                if (better) {
                    memcpy(best_combo, curr_combo, j * sizeof(int));
                    best_stats = stats;
                }

                // Generate next combination
                int i = j - 1;
                while (i >= 0 && curr_combo[i] == max_number - j + i + 1) i--;
                if (i < 0) break;
                curr_combo[i]++;
                for (int x = i + 1; x < j; x++) curr_combo[x] = curr_combo[i] + x - i;

            } while (1);

            free(curr_combo);

            // Check for common subsets
            int draws_until_match = 0;
            int found = 0;

            for (int d = draws_count - use_count; d < draws_count && !found; d++) {
                draws_until_match++;

                // Check if any k-subset matches
                int c[20];
                for (int i = 0; i < k; i++) c[i] = i;

                while (!found && c[0] <= j-k) {
                    int subset[20];
                    for (int i = 0; i < k; i++) subset[i] = best_combo[c[i]];

                    uint64 subset_mask = to_bitmask(subset, k);
                    uint64 draw_mask = to_bitmask(draws[d], 6);

                    if (__builtin_popcountll(subset_mask & draw_mask) == k) {
                        found = 1;
                        break;
                    }

                    // Next k-combination of j numbers
                    int i = k - 1;
                    while (i >= 0 && c[i] == j - k + i) i--;
                    if (i < 0) break;
                    c[i]++;
                    for (int x = i + 1; x < k; x++) c[x] = c[i] + x - i;
                }
            }

            if (!found) draws_until_match = use_count;

            // Store result
            AnalysisResultItem* outR = &results[*out_len];
            outR->is_chain_result = 1;
            outR->draw_offset = current_offset;
            outR->analysis_start_draw = draws_count - current_offset;
            outR->draws_until_common = draws_until_match - 1;

            combo_to_string(best_combo, j, outR->combination);
            outR->avg_rank = best_stats.avg_rank;
            outR->min_value = best_stats.min_rank;
            format_subsets(best_combo, j, k, tracker, outR->subsets);

            (*out_len)++;

            if (!found) break;
            current_offset = current_offset - draws_until_match;
        }
    } else {
        // Normal analysis
        ComboStats* best_combos = (ComboStats*)malloc(l * sizeof(ComboStats));
        int filled = 0;

        int* curr_combo = (int*)malloc(j * sizeof(int));
        for (int i = 0; i < j; i++) curr_combo[i] = i + 1;

        do {
            ComboStats stats;
            evaluate_combo(curr_combo, j, k, tracker, &stats);

            if (filled < l) {
                memcpy(best_combos[filled].combo, curr_combo, j * sizeof(int));
                best_combos[filled].combo_len = j;
                best_combos[filled].avg_rank = stats.avg_rank;
                best_combos[filled].min_rank = stats.min_rank;
                best_combos[filled].total_draws = stats.total_draws;
                filled++;

                // Sort by descending order
                for (int i = filled - 1; i > 0; i--) {
                    int should_swap = 0;
                    if (strcmp(m, "avg") == 0) {
                        should_swap = best_combos[i].avg_rank > best_combos[i-1].avg_rank;
                    } else {
                        should_swap = best_combos[i].min_rank > best_combos[i-1].min_rank;
                    }

                    if (should_swap) {
                        ComboStats tmp = best_combos[i];
                        best_combos[i] = best_combos[i-1];
                        best_combos[i-1] = tmp;
                    } else break;
                }
            } else {
                int should_replace = 0;
                if (strcmp(m, "avg") == 0) {
                    should_replace = stats.avg_rank > best_combos[l-1].avg_rank;
                } else {
                    should_replace = stats.min_rank > best_combos[l-1].min_rank;
                }

                if (should_replace) {
                    best_combos[l-1].avg_rank = stats.avg_rank;
                    best_combos[l-1].min_rank = stats.min_rank;
                    best_combos[l-1].total_draws = stats.total_draws;
                    memcpy(best_combos[l-1].combo, curr_combo, j * sizeof(int));
                    best_combos[l-1].combo_len = j;

                    // Bubble up
                    for (int i = l-1; i > 0; i--) {
                        int should_swap = 0;
                        if (strcmp(m, "avg") == 0) {
                            should_swap = best_combos[i].avg_rank > best_combos[i-1].avg_rank;
                        } else {
                            should_swap = best_combos[i].min_rank > best_combos[i-1].min_rank;
                        }

                        if (should_swap) {
                            ComboStats tmp = best_combos[i];
                            best_combos[i] = best_combos[i-1];
                            best_combos[i-1] = tmp;
                        } else break;
                    }
                }
            }

            // Generate next combination
            int i = j - 1;
            while (i >= 0 && curr_combo[i] == max_number - j + i + 1) i--;
            if (i < 0) break;
            curr_combo[i]++;
            for (int x = i + 1; x < j; x++) curr_combo[x] = curr_combo[i] + x - i;

        } while (1);

        free(curr_combo);

        // Store results
        for (int i = 0; i < filled; i++) {
            AnalysisResultItem* outR = &results[*out_len];
            outR->is_chain_result = 0;

            combo_to_string(best_combos[i].combo, best_combos[i].combo_len, outR->combination);
            outR->avg_rank = best_combos[i].avg_rank;
            outR->min_value = best_combos[i].min_rank;
            format_subsets(best_combos[i].combo, j, k, tracker, outR->subsets);

            (*out_len)++;
        }

        // Handle non-overlapping combos if requested
        if (n > 0) {
            for (int i = 0; i < filled && *out_len < capacity; i++) {
                AnalysisResultItem* outR = &results[*out_len];
                outR->is_chain_result = 0;

                combo_to_string(best_combos[i].combo, best_combos[i].combo_len, outR->combination);
                outR->avg_rank = best_combos[i].avg_rank;
                outR->min_value = best_combos[i].min_rank;
                format_subsets(best_combos[i].combo, j, k, tracker, outR->subsets);

                (*out_len)++;
            }
        }

        free(best_combos);
    }

    free_tracker(tracker);

    if (*out_len > MAX_ALLOWED_OUT_LEN) {
        fprintf(stderr, "Error: out_len=%d exceeds safety limit %d.\n", *out_len, MAX_ALLOWED_OUT_LEN);
        free(results);
        results = NULL;
        *out_len = 0;
    }

    return results;
}

void free_analysis_results(AnalysisResultItem* results) {
    if (results) {
        free(results);
    }
}

C_engine/src/analysis_engine.h
#ifndef ANALYSIS_ENGINE_H
#define ANALYSIS_ENGINE_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    char combination[256];
    double avg_rank;
    double min_value;
    char subsets[512];
    int draw_offset;
    int draws_until_common;
    int analysis_start_draw;
    int is_chain_result;
} AnalysisResultItem;

AnalysisResultItem* run_analysis_c(
    const char* game_type,
    int** draws,
    int draws_count,
    int j,
    int k,
    const char* m,
    int l,
    int n,
    int last_offset,
    int* out_len
);

void free_analysis_results(AnalysisResultItem* results);

#ifdef __cplusplus
}
#endif

#endif

</current_code>

<goals>

</goals>

<constraints>

</constraints>

For any file you change, generate it end-to-end.

